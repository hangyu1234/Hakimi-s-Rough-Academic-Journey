# MIT 6.006：Introduction to Algorithms
本部编号 2026-5-B
___
## 目录<a id = "目录"></a>
[Lecture 1: Introduction](#l1)<br>
[Lecture 2: Data Structures](#l2)<br>
[Lecture 3: Sorting](#l3)<br>
[Lecture 4: Hashing](#l4)<br>
[Lecture 5: Linear Sorting](#l5)<br>
[Lecture 6: Binary Trees I](#l6)<br>
[Lecture 7: Binary Trees II](#l7)<br>
[Lecture 8: Binary Heaps](#l8)<br>
[Lecture 9: Breadth-First Search](#l9)<br>
[Lecture 10: Depth-First Search](#l10)<br>
[Lecture 11: Weighted Shortest Paths](#l11)<br>
[Lecture 12: Bellman-Ford](#l12)<br>
[Lecture 13: Dijkstra's Algorithm](#l13)<br>
[Lecture 14: Johnson's Algorithm](#l14)<br>
[Lecture 15: Dynamic Programming I](#l15)<br>
[Lecture 16: Dynamic Programming II](#l16)<br>
[Lecture 17: Dynamic Programming III](#l17)<br>
[Lecture 18: Dynamic Programming IV](#l18)<br>
[Lecture 19: Complexity](#l19)<br>
[Lecture 20: Course Review](#l20)<br>
___
## Lecture 1: Introduction<a id = "l1"></a>
### 1. 问题
从问题输入到正确输出的二元关系
通常不会为所有输入指定每一个正确输出（数量太多！）
提供一个可验证的谓词（属性），正确输出必须满足该属性
- 非通用： 小的输入实例
- 通用： 任意大的输入
### 2. 算法
将每个输入映射到单个输出的过程（确定性）
如果一个算法为每个问题输入都返回正确的输出，那么它就解决了一个问题
例子：一个解决生日匹配问题的算法
- 维护一个姓名和生日的记录（初始为空）
- 按某种顺序询问每个学生
   - 如果生日已存在于记录中，返回找到的配对！
   - 否则，将姓名和生日添加到记录中
- 如果询问完最后一个学生仍未成功，返回"无"
### 3. 正确性
程序/算法有固定的大小，那么如何证明其正确？
对于小输入，可以使用案例分析
对于任意大的输入，算法必须以某种方式递归或循环
必须使用归纳法（这就是为什么递归是计算机科学中如此关键的概念）
例子：生日匹配算法的正确性证明
对 k（记录中的学生数量）进行归纳
- 归纳假设：如果前 k 个学生中存在匹配，算法会在询问第 k+1 个学生前返回匹配
- 基础情况：k=0，前 k 个学生不含匹配
- 假设归纳假设对 k = k0 成立，考虑 k = k0+1
   - 如果前 k0 个学生包含匹配，根据归纳法，算法已返回匹配
   - 否则，前 k0 个学生没有匹配，因此如果前 k0+1 个学生有匹配，则匹配必然包含第 k0+1 个学生，接着，算法直接检查第 k0+1 个学生的生日是否在前 k0 个学生的记录中
### 4. 效率
算法多快能产生正确的输出？
可以测量时间，但希望性能与机器无关
思路：计算算法返回结果所执行的固定时间操作的数量
- 预期依赖于输入的大小：输入越大通常意味着时间越长
- 输入的大小通常被称为'n'，但不总是！
- 如果相对于输入能在多项式时间内返回，则是高效的
（有时对于某个问题不存在高效的算法！）

渐进表示法： 忽略常数因子和低阶项
- 上界 (O)，下界 (Ω)，紧确界 (Θ) 
- 下表的时间估算基于 1 GHz 单核机器上每个周期执行一个操作
- 宇宙中的粒子数估计 < $10^100$

| 输入大小 | 常数时间 | 对数时间 | 线性时间 | 线性对数时间 | 平方时间 | 多项式时间 | 指数时间 |
|---|---|---|---|---|---|---|---|
| \( n \) | \( \Theta(1) \) | \( \Theta(\log n) \) | \( \Theta(n) \) | \( \Theta(n \log n) \) | \( \Theta(n^2) \) | \( \Theta(n^c) \) | \( 2^{\Theta(n^c)} \) |
| 1000   | 1    | ≈ 10    | 1000   | ≈ 10,000  | 1,000,000 | \( 1000^c \) | \( 2^{1000} \approx 10^{301} \) |
| 时间    | 1 ns    | 10 ns    | 1 μs    | 10 μs    | 1 ms    | \( 10^{3c-9} s \) | \( 10^{281} \) 千年 |
### 5. 计算模型
规定在机器上哪些操作可以在 O(1) 时间内完成
本课程使用的模型称为字 RAM
机器字： w 比特的块（w 是 w 位字 RAM 的字长）
内存： 可寻址的机器字序列
处理器支持对 O(1) 个字（整数）进行的多种常数时间操作：
- 整数算术：(+, -, *, //, %)
- 逻辑运算符：(&&, ||, !, ==, <, >, <=, >=)
- （按位算术：(&, |, <<, >>, ...)）
- 给定字 a，可以读取地址 a 处的字，将字写入地址 a

内存地址必须能够访问内存中的每一个位置
- 要求：w ≥ 表示最大内存地址所需的比特数，即 log₂n
- 32 位字 → 最大约 4 GB 内存，64 位字 → 最大约 16 艾字节内存

Python 是一个更复杂的计算模型，它建立在字 RAM 之上实现
### 6. 数据结构
数据结构是一种存储非常量数据的方式，它支持一组操作
一组操作的集合称为一个接口
- 序列： 项目具有外在顺序（第一个、最后一个、第 n 个）
- 集合： 项目具有内在顺序（基于项目键进行查询）

不同的数据结构可能实现相同的接口，但性能不同
例子：静态数组：固定宽度的槽，固定长度，静态序列接口
- StaticArray(n)：分配大小为 n 的静态数组并初始化为 0，Θ(n) 时间
- StaticArray.get_at(i)：返回数组索引 i 处存储的字，Θ(1) 时间
- StaticArray.set_at(i, x)：将字 x 写入数组索引 i 处，Θ(1) 时间

存储的字可以包含一个更大对象的地址
类似于 Python 元组加上 set_at(i, x) 功能，Python 列表是一个动态数组
### 7. 例子：运行时间分析
```python
def birthday_match(students):
    '''
    找出生日相同的一对学生
    输入：由 (姓名, 生日) 元组构成的元组
    输出：由两个姓名构成的元组或 None
    '''
    n = len(students) # O(1)
    record = StaticArray(n) # O(n)
    for k in range(n): # n 次循环
        (name1, bday1) = students[k] # O(1)
        # 如果 bday1 在 record 中，则返回配对
        for i in range(k): # k 次循环
            (name2, bday2) = record.get_at(i) # O(1)
            if bday1 == bday2: # O(1)
                return (name1, name2) # O(1)
        record.set_at(k, (name1, bday1)) # O(1)
    return None # O(1)
```
两个循环：外层 k ∈ {0,...,n−1}，内层 i ∈ {0,...,k}
运行时间是 O(n) + $Σ_{k=0}^{n-1}$ (O(1) + k·O(1)) = O(n²)
相对于 n 是平方级的，属于多项式。高效吗？使用不同的数据结构来实现记录！
### 8. 如何解决一个算法问题
- 化归为已知问题（使用数据结构或算法）

| 搜索问题（数据结构） | 排序算法 | 最短路径算法 |
|-------------------|----------|--------------|
| 静态数组  | 插入排序  | 广度优先搜索  |
| 链表  | 选择排序  | DAG 松弛算法  |
| 动态数组  | 归并排序  | 深度优先搜索  |
| 有序数组  | 计数排序  | 拓扑排序 |
| 直接访问数组  | 基数排序 | 贝尔曼-福特算法  |
| 哈希表  | AVL 排序  | 戴克斯特拉算法  |
| 平衡二叉树  | 堆排序  | 约翰逊算法 |
| 二叉堆  | | 弗洛伊德-沃尔什算法 |
- 设计你自己的（递归）算法
   - 暴力法
   - 减治法
   - 分治法
   - 动态规划
   - 贪心法/增量法
___
[返回目录](#目录)
___
## Lecture 2: Data Structures<a id = "l2"></a>
### 1. 数据结构接口
数据结构是一种存储数据的方式，并附带有支持对数据执行操作的算法。
所支持的操作集合称为接口（也称为 API 或 ADT）。
接口是一种规范：说明支持哪些操作（即问题）。
数据结构是一种表示：说明如何支持这些操作（即解决方案！）。
本课程中，有两个主要接口：序列和集合。
### 2. 序列接口
维护一个项目的序列（顺序是外在的）。
支持序列操作：
|类别|操作|描述|
| :---: | :---: | :---: |
|容器操作|build(X)|给定可迭代对象 X，用 X 中的项目构建序列|
| |len()|返回存储的项目数量|
|静态操作|iter_seq()|按序列顺序逐个返回存储的项目|
| |get_at(i)|返回第 i 个项目|
| |set_at(i, x)|用 x 替换第 i 个项目|
|动态操作|insert_at(i, x)|将 x 添加为第 i 个项目|
| |delete_at(i)|移除并返回第 i 个项目|
| |insert_first(x)|将 x 添加为第一个项目|
| |delete_first()|移除并返回第一个项目|
| |insert_last(x)|将 x 添加为最后一个项目|
| |delete_last()|移除并返回最后一个项目|
- 特殊案例接口：
栈： insert_last(x) 和 delete_last()
队列： insert_last(x) 和 delete_first()
### 3. 集合接口
序列关注外在顺序，集合关注内在顺序。
维护一个具有唯一键的项目集合（例如，项目 x 具有键 x.key）。
（是集合还是多重集合？我们暂时限制为唯一键。）
通常我们让项目的键就是项目本身，但可能希望存储比键更多的信息。
支持集合操作：
|类别|操作|描述|
| :---: | :---: | :---: |
|容器操作|build(X)|给定可迭代对象 X，用 X 中的项目构建序列|
| |len()|返回存储的项目数量|
|静态操作|find(k)|返回键为 k 的存储项目|
|动态操作|insert(x)|将 x 添加到集合中（如果已存在键为 x.key 的项目，则替换之）|
| |delete(k)|移除并返回键为 k 的存储项目|
|有序操作|iter_ord()|按键顺序逐个返回存储的项目
| |find_min()|返回具有最小键的存储项目|
| |find_max()|返回具有最大键的存储项目|
| |find_next(k)|返回键大于 k 的最小键存储项目|
| |find_prev(k)|返回键小于 k 的最大键存储项目|
- 特殊案例接口：
字典： 不支持有序操作的集合。
### 4. 数组序列
数组非常适合静态操作！get_at(i) 和 set_at(i, x) 只需 Θ(1) 时间！
但对于动态操作就没那么好了...
（为了一致性，我们保持数组已满的不变式）
那么插入和移除项目需要：
- 重新分配数组
- 移动修改项之后的所有项目

![p1](./笔记插图集/p1.png)
### 5. 链表序列
指针数据结构（这与 Python 的“list”无关）。
每个项目存储在一个节点中，该节点包含一个指向序列中下一个节点的指针。
每个节点有两个字段：node.item 和 node.next。
可以通过重新链接指针来简单地操作节点！
维护指向序列中第一个节点的指针（称为头节点）。
现在可以从前端在 Θ(1) 时间内插入和删除！耶！
（从后端高效插入/删除也是可能的；你将在 PS1 中完成）。
但现在 get_at(i) 和 set_at(i, x) 都需要 O(n) 时间...
我们能两者兼顾吗？能！（某种程度上...）
![p2](./笔记插图集/p2.png)
### 6. 动态数组序列
使数组对末端的动态操作高效。
Python 的 "list" 就是一个动态数组。
思路！ 分配额外空间，这样就不会在每次动态操作时都重新分配。
填充率： 0 ≤ r ≤ 1，项目数量与空间容量的比率。
每当数组已满（r = 1）时，在末尾分配 Θ(n) 的额外空间，使填充率达到 ri（例如 1/2）。
在下一次重新分配之前，将需要插入 Θ(n) 个项目。
一次单独的操作可能需要 Θ(n) 的时间用于重新分配。
然而，任何连续的 Θ(n) 次操作总共只需要 Θ(n) 时间。
因此，每次操作“平均”需要 Θ(1) 时间。
### 7. 摊销分析
数据结构分析技术，将成本分摊到多次操作上。
如果 k 次操作的总成本 ≤ kT(n)，则说该操作具有摊销成本 T(n)。
“T(n) 摊销”大致意味着在许多次操作中“平均”来看是 T(n)。
插入到动态数组需要 Θ(1) 的摊销时间。
### 8. 动态数组删除
从末尾删除？毫不费力，Θ(1) 时间
然而，在空间上可能非常浪费。希望数据结构的大小保持在 Θ(n)。
尝试：如果数组变得非常空，重新调整到 r = 1。交替进行插入和删除可能很糟糕...
思路：当 r < rd 时，将数组大小调整到比率 ri，其中 rd < ri（例如 rd = 1/4, ri = 1/2）。
那么在下一次昂贵的调整大小之前，必须进行 Θ(n) 次廉价操作。
对于任意 ε > 0，可以将额外空间使用限制在 (1 + ε)n 内（设 $r_d = \frac{ε}{1+ε}$, $r_i = \frac{1+r_d}{2}$
动态数组仅支持在 Θ(1) 时间内进行末端的动态操作。
Python List 的 append 和 pop 是摊销 O(1) 时间，其他操作可能是 O(n)！
![p3](./笔记插图集/p3.png)
___
[返回目录](#目录)
___
## Lecture 3: Sorting<a id = "l3"></a>
### 1. 集合接口
|类别|操作|描述|
| :---: | :---: | :---: |
|容器操作|build(X)|给定可迭代对象 X，用 X 中的项目构建序列|
| |len()|返回存储的项目数量|
|静态操作|find(k)|返回键为 k 的存储项目|
|动态操作|insert(x)|将 x 添加到集合中（如果已存在键为 x.key 的项目，则替换之）|
| |delete(k)|移除并返回键为 k 的存储项目|
|有序操作|iter_ord()|按键顺序逐个返回存储的项目
| |find_min()|返回具有最小键的存储项目|
| |find_max()|返回具有最大键的存储项目|
| |find_next(k)|返回键大于 k 的最小键存储项目|
| |find_prev(k)|返回键小于 k 的最大键存储项目|

以任意顺序将项目存储在数组中可以实现一个（效率不太高的）集合
按键递增顺序存储项目（排序数组）允许：
- 更快的 find_min/find_max（位于数组的第一个和最后一个索引）
- 通过二分查找实现更快的 find：O(log n)

但是如何高效地构造一个排序数组？
![p4](./笔记插图集/p4.png)
给定一个排序数组，我们可以利用二分查找来创建一个高效集合数据结构。
### 2. 排序问题
输入： （静态）包含 n 个数字的数组 A
输出： （静态）数组 B，它是 A 的一个排序排列
- 排列：包含相同元素但顺序不同的数组
- 排序：对于所有 i ∈ {1, ..., n}，有 B[i-1] ≤ B[i]

例子： [8, 2, 4, 9, 3] → [2, 3, 4, 8, 9]
如果一个排序会覆盖 A（而不是创建一个新的排序版本数组 B），则它是破坏性的
如果一个排序使用 O(1) 额外空间，则它是原地的（意味着是破坏性的：原地 ⊆ 破坏性）
### 3. 排列排序
A 有 n! 种排列，其中至少有一种是排好序的
对于每种排列，用 Θ(n) 时间检查是否已排序
例子： [2, 3, 1] → {[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]}
```python
def permutation_sort(A):
    for B in permutations(A): # 尝试所有排列
        if is_sorted(B):      # 检查是否排序
            return B
```
排列排序分析：
- 通过案例分析证明正确性：尝试所有可能性（暴力法）
- 运行时间：Ω(n! · n)，这是指数级的
### 4. 求解递归式
代换法： 猜测一个解，用代表函数替换，递归式成立
递归树： 绘制一个表示递归调用的树，并计算节点上的总和
主定理： 一个解决多种递归式的公式
### 5. 选择排序
找到前缀 A[:i+1] 中的最大数字，并将其交换到 A[i] 的位置
递归地对前缀 A[:i] 进行排序
例子： [8, 2, 4, 9, 3], [8, 2, 4, 3, 9], [3, 2, 4, 8, 9], [3, 2, 4, 8, 9], [2, 3, 4, 8, 9]
```python
def selection_sort(A, i=None): # T(i)
    if i is None: i = len(A) - 1
    if i > 0:
        j = prefix_max(A, i)   # 找到前缀最大值的索引
        A[i], A[j] = A[j], A[i] # 交换到末尾
        selection_sort(A, i - 1) # 递归排序剩余部分

def prefix_max(A, i): # S(i)
    '''返回 A[:i + 1] 中最大值的索引'''
    if i > 0: # O(1)
        j = prefix_max(A, i - 1) # S(i - 1)
        if A[i] < A[j]: # O(1)
            return j # O(1)
    return i # O(1)
```
prefix_max 分析：
- 基础情况： 当 i=0 时，数组只有一个元素，所以最大值的索引就是 i
- 归纳： 假设对于 i 正确，最大值要么是 A[:i] 的最大值，要么是 A[i]，无论哪种情况都返回正确的索引。
- S(1) = Θ(1), S(n) = S(n-1) + Θ(1)
   - 代换法： S(n) = Θ(n), cn = Θ(1) + c(n-1) => 1 = Θ(1)
   - 递归树： 一条包含 n 个节点的链，每个节点 Θ(1) 工作，$Σ_{i=0}^{n-1} 1 = Θ(n)$

selection_sort 分析：
- 基础情况： 当 i=0 时，数组只有一个元素，因此已排序
- 归纳： 假设对于 i 正确，排序输出的最后一个数字是数组的一个最大数，并且算法把一个最大值放在那里；然后根据归纳，A[:i] 被排序了。
- T(1) = Θ(1), T(n) = T(n-1) + Θ(n)
   - 代换法： T(n) = Θ(n²), cn² = Θ(n) + c(n-1)² => c(2n - 1) = Θ(n)
   - 递归树： 一条包含 n 个节点的链，每个节点 Θ(i) 工作，$Σ_{i=0}^{n-1} i = Θ(n²)$
### 6. 插入排序
递归地对前缀 A[:i] 进行排序
在假设前缀 A[:i] 已排序的前提下，通过重复交换来对前缀 A[:i+1] 进行排序
例子： [8, 2, 4, 9, 3], [2, 8, 4, 9, 3], [2, 4, 8, 9, 3], [2, 4, 8, 9, 3], [2, 3, 4, 8, 9]
```python
def insertion_sort(A, i=None): # T(i)
    if i is None: i = len(A) - 1
    if i > 0:
        insertion_sort(A, i - 1) # 先排序前缀
        insert_last(A, i)       # 再插入最后一个元素

def insert_last(A, i): # S(i)
    '''假设 A[:i] 已排序，排序 A[:i+1]'''
    if i > 0 and A[i] < A[i-1]: # O(1)
        A[i], A[i-1] = A[i-1], A[i] # O(1) 交换
        insert_last(A, i - 1) # S(i-1)
```
insert_last 分析：
- 基础情况： 当 i=0 时，数组只有一个元素，因此已排序
- 归纳： 假设对于 i 正确，如果 A[i] >= A[i-1]，数组已排序；否则，交换最后两个元素允许我们通过归纳对 A[:i] 进行排序。
- S(1) = Θ(1), S(n) = S(n-1) + Θ(1) => S(n) = Θ(n)

insertion_sort 分析：
- 基础情况： 当 i=0 时，数组只有一个元素，因此已排序
- 归纳： 假设对于 i 正确，算法通过归纳对 A[:i] 排序，然后如上所证，insert_last 正确地对其余部分排序。
- T(1) = Θ(1), T(n) = T(n-1) + Θ(n) => T(n) = Θ(n²)
### 7. 归并排序
递归地对前半部分和后半部分进行排序（可以假设 n 是 2 的幂）
将已排序的两半合并成一个排序列表（双指针算法）
例子： [7, 1, 5, 6, 2, 4, 9, 3], [1, 7, 5, 6, 2, 4, 3, 9], [1, 5, 6, 7, 2, 3, 4, 9], [1, 2, 3, 4, 5, 6, 7, 9]
```python
def merge_sort(A, a=0, b=None): # T(b - a = n)
    '''对 A[a:b] 排序'''
    if b is None: b = len(A) # O(1)
    if 1 < b - a: # O(1)
        c = (a + b + 1) // 2 # O(1)
        merge_sort(A, a, c) # T(n / 2)
        merge_sort(A, c, b) # T(n / 2)
        L, R = A[a:c], A[c:b] # O(n)
        merge(L, R, A, len(L), len(R), a, b) # S(n)

def merge(L, R, A, i, j, a, b): # S(b - a = n)
    '''将已排序的 L[:i] 和 R[:j] 合并到 A[a:b]'''
    if a < b: # O(1)
        if (j <= 0) or (i > 0 and L[i-1] > R[j-1]): # O(1)
            A[b-1] = L[i-1] # O(1)
            i = i - 1 # O(1)
        else: # O(1)
            A[b-1] = R[j-1] # O(1)
            j = j - 1 # O(1)
        merge(L, R, A, i, j, a, b-1) # S(n-1)
```
merge 分析：
- 基础情况： 当 n=0 时，数组为空，因此显然正确。
- 归纳： 假设对于 n 正确，A[r] 中的项目必须是 L 和 R 剩余前缀中最大的数，并且由于它们已排序，取最后项中最大的一个就足够了；剩余部分通过归纳合并。
- S(0) = Θ(1), S(n) = S(n-1) + Θ(1) => S(n) = Θ(n)

merge_sort 分析：
- 基础情况： 当 n=1 时，数组只有一个元素，因此已排序。
- 归纳： 假设对于 k < n 正确，算法通过归纳对较小的两半进行排序，然后 merge 如上所证合并成一个排序数组。
- T(1) = Θ(1), T(n) = 2T(n/2) + Θ(n)
   - 代换法： 猜测 T(n) = Θ(n log n) cn log n = Θ(n) + 2c(n/2) log(n/2) => cn log(2) = Θ(n)
   - 递归树： 深度为 log₂n、有 n 个叶子的完全二叉树，第 i 层有 2^i 个节点，每个节点 O(n/2^i) 工作，总工作：$Σ_{i=0}^{log₂n} (2^i)(n/2^i) = Σ_{i=0}^{log₂n} n = Θ(n log n)$
___
[返回目录](#目录)
___
## Lecture 4: Hashing<a id = "l4"></a>
### 1. 比较模型
在此模型中，假设算法只能通过比较来区分项目。
可比较项目： 黑盒，只支持对项目对进行比较。
比较操作是 <, ≤, >, ≥, =, ≠，输出是二元的：真或假。
目标： 存储 n 个可比较项目的集合，支持 find(k) 操作。
运行时间以执行的比较次数为下界，所以计数比较次数！
### 2. 决策树
任何算法都可以看作是执行的操作的决策树。
一个内部节点表示一个二元比较，根据结果为真或假进行分支。
对于比较算法，决策树是二叉的（绘制示例）。
一个叶子节点表示算法终止，产生一个算法输出。
一条从根到叶的路径表示算法在某个输入上的执行过程。
需要为每个算法输出至少有一个叶子，因此搜索需要 ≥ n + 1 个叶子。
### 3. 比较搜索下界
比较搜索算法的最坏情况运行时间是什么？
运行时间 ≥ 比较次数 ≥ 任何根到叶路径的最大长度 ≥ 树的高度
任意具有 ≥ n 个节点的二叉树的最小高度是多少？
当二叉树是完全二叉树时（除了最后一行外所有行都满），高度最小。
高度 ≥ ⌈lg(n+1)⌉ - 1 = Ω(log n)，因此任何比较排序的运行时间是 Ω(log n)。
排序数组达到了这个界
更一般地说，具有 Θ(n) 个叶子和最大分支因子 b 的树的高度是 Ω($log_b n$)。
为了更快，需要一个允许超常数 ω(1) 分支因子的操作。
### 4. 直接访问数组
利用字 RAM O(1) 时间随机访问索引！线性分支因子！
给项目分配唯一的整数键 k ∈ {0, ..., u-1}，将项目存储在数组的索引 k 处。
将数组的每个索引与一个含义关联起来。
如果键能放入一个机器字中，即 $u ≤ 2^w$，则最坏情况 O(1) 的 find/动态操作
假设： 输入的数字/字符串能放入一个字中，除非长度被明确参数化。
计算机内存中的任何东西都是一个二进制整数，或者使用（静态）64 位内存地址。
但是空间 O(u)，所以如果 n << u（即 n 远小于 u）会非常糟糕
例子： 如果键是十个字母的名字，即使每个名字只占一个比特，也需要 $26^{10} ≈ 17.6$ TB 的空间。
我们怎么能使用更少的空间？
### 5. 哈希
如果 n << u，将键映射到一个较小的范围 m = Θ(n)，并使用较小的直接访问数组。
哈希函数： h(k) : {0, ..., u-1} → {0, ..., m-1}（也称哈希映射）。
直接访问数组称为哈希表，h(k) 称为键 k 的哈希值。
如果 m < u，根据鸽巢原理，没有哈希函数是单射的。
总是存在键 a, b 使得 h(a) = h(b) → 冲突！
不能将两个项目存储在同一索引处，那么存储在哪里呢？要么：
- 存储在数组中的其他地方（开放寻址法）
分析复杂，但常见且实用。
- 存储在支持动态集合接口的另一个数据结构中（链地址法）。
### 6. 链地址法
将冲突存储在另一个数据结构（一条链）中。
如果键大致均匀分布在各个索引上，链的大小是 n/m = n/Ω(n) = O(1)！
如果链的大小是 O(1)，那么所有操作都在 O(1) 时间内完成
如果不是，许多项目可能映射到同一位置，例如 h(k) = 常数，链大小是 Θ(n)
需要好的哈希函数！那么什么是好的哈希函数？
### 7. 哈希函数
1. 取模法（不好）：
h(k) = (k mod m)
启发式方法，当键均匀分布时很好！
m 应避免与存储键的对称性冲突。
远离 2 和 10 的幂的大素数可能是合理的。
Python 使用了一个带有额外混合处理的版本。
如果 u >> n，每个哈希函数都有某个输入集合会创建大小为 O(n) 的链。
不要使用固定的哈希函数！随机选择一个（但要小心）！
2. 通用哈希函数（好，理论上）：
$$h_{ab}(k) = ( (a*k + b) \mod p ) \mod m$$
哈希函数族 $H(p, m) = \{ h_{ab} | a, b ∈ {0, ..., p-1} 且 a ≠ 0 \}$。
由固定素数 p > u 参数化，a 和 b 从范围 {0, ..., p-1} 中选择。
H 是一个通用族：对于任意 $ki ≠ kj ∈ {0, ..., u-1}$，有 $Pr_{h∈H} { h(ki) = h(kj) } ≤ 1/m$。
• 为什么通用性有用？意味着链长度很短！（在期望意义上）
• $X_ij$ 是关于 h ∈ H 的指示随机变量：如果 $h(k_i) = h(k_j) 则 X_{ij} = 1$，否则为 0。
• 索引 $h(k_i)$ 处的链大小是随机变量 $X_i = Σ_j X_{ij}$。
• 索引 $h(k_i)$ 处链的期望大小：
$$
\begin{aligned}
E_{h∈H} { X_i } &= E_{h∈H} { Σ_j X_ij } = Σ_j E_{h∈H} { X_ij } = 1 + Σ_{j≠i} E_{h∈H} { X_ij }\\
&= 1 + Σ_{j≠i} [ (1) * Pr_{h∈H} { h(ki) = h(kj) } + (0) * Pr_{h∈H} { h(ki) ≠ h(kj) } ]\\
&≤ 1 + Σ_{j≠i} 1/m = 1 + (n - 1)/m
\end{aligned}
$$
由于 m = Ω(n)，装载因子 α = n/m = O(1)，所以期望 O(1)
### 8. 动态操作
如果 n/m 远离 1，使用新的随机选择的哈希函数为新的大小 m 重建哈希表。
分析与动态数组相同，成本可以摊销到多次动态操作上。
因此，哈希表可以在期望摊销 O(1) 时间内实现动态集合操作！
![p5](./笔记插图集/p5.png)
___
[返回目录](#目录)
___
## Lecture 5: Linear Sorting<a id = "l5"></a>
### 1. 比较排序的下界
比较模型意味着算法的决策树是二叉树（分支因子恒定）。
要求树的叶子节点数 L ≥ 可能的输出数量。
树高的下界是 Ω(log L)，因此最坏情况运行时间也是 Ω(log L)。
对包含 n 个元素的数组排序，可能的输出数量是 n! 种排列。
因此树高的下界为 log(n!) ≥ log((n/2)^(n/2)) = Ω(n log n)。
所以，在比较模型中，归并排序是最优的。
那么，我们能否利用直接访问数组来实现更快的排序呢？
### 2. 直接访问数组排序
示例：[5, 2, 7, 0, 4]
假设所有键值都是范围在 {0, ..., u-1} 内的唯一非负整数，因此 n ≤ u。
将每个元素插入到一个大小为 u 的直接访问数组中：Θ(n)。
按照元素在直接访问数组中出现的顺序返回它们：Θ(u)。
总运行时间为 Θ(u)。如果 u = Θ(n)，那么运行时间就是 Θ(n)。太好了！
```python
def direct_access_sort(A):
    "Sort A assuming items have distinct non-negative keys"
    u = 1 + max([x.key for x in A])  # O(n) 找到最大键值
    D = [None] * u                   # O(u) 创建直接访问数组
    for x in A:                      # O(n) 插入元素
        D[x.key] = x
    i = 0
    for key in range(u):             # O(u) 按顺序读出元素
        if D[key] is not None:
            A[i] = D[key]
            i += 1
```
问题：如果键值范围更大，比如 u = Ω(n^2)（即至少与 n^2 同阶）呢？
思路：将每个键值 k 表示为一个元组 (a, b)，其中 k = a * n + b，且 0 ≤ b < n。
具体来说：a = k // n（小于 n），b = k % n（这就像一个基于 n 的两位数！）。
在Python中，可以使用内置操作：(a, b) = divmod(k, n)。
示例：[17, 3, 24, 22, 12]（n=5）⇒ [(3,2), (0,3), (4,4), (4,2), (2,2)] ⇒ [32, 03, 44, 42, 22]。
那么我们如何对元组进行排序呢？
### 3. 元组排序
元素的键值是等长元组，例如 item.key = (k1, k2, k3, ...)。
我们希望按照字典序对所有条目进行排序，因此第一个键 k1 是最高有效位。
如何排序？思路！ 使用其他的辅助排序算法来分别对每个键进行排序。
（就像在电子表格中按多列对行进行排序一样）。
应该按什么顺序对它们排序？从最低有效位到最高有效位！
示例：[32, 03, 44, 42, 22] ⇒ [42, 22, 32, 03, 44] ⇒ [03, 22, 32, 42, 44]（n=5）。
思路！ 使用辅助的直接访问数组排序对元组 (a, b) 进行元组排序。
问题！ 即使输入键值互不相同，也可能有很多整数具有相同的 a 或 b 值。
我们需要一种能处理重复键值并保持输入顺序的排序算法。
我们希望排序是稳定的：重复的键值在输出中出现的顺序与输入中相同。
直接访问数组排序甚至无法处理有重复键值的数组！
我们能否修改直接访问数组排序，使其能以稳定的方式处理多个相同的键值？
### 4. 计数排序
与其在每个数组索引处存储单个元素，不如像哈希表一样存储一个链！
为了保证稳定性，链式数据结构应该记住元素被添加的顺序。
使用一个能维护插入顺序的序列数据结构。
要插入元素 x，就将其插入到索引 x.key 处链的末尾。
然后排序时，按顺序遍历所有链，逐个返回元素。
```python
def counting_sort(A):
    "Sort A assuming items have non-negative keys"
    u = 1 + max([x.key for x in A])       # O(n) 找到最大键值
    D = [[] for i in range(u)]            # O(u) 创建链式直接访问数组
    for x in A:                           # O(n) 插入到链 x.key 的末尾
        D[x.key].append(x)
    i = 0
    for chain in D:                       # O(u) 按顺序读取元素
        for x in chain:
            A[i] = x
            i += 1
```
### 5. 基数排序
思路！ 如果 $u < n^2$，就使用辅助计数排序对元组 (a, b) 进行元组排序。
先对最低有效位 b 排序，再对最高有效位 a 排序。
稳定性保证了前一步的排序顺序得以保持。
该算法的运行时间是 O(2n) = O(n)。太好了！
如果每个键值都 < $n^c$（其中 c 是常数，且 $c = log_n(u)$），那么每个键值在 n 进制下最多有 c 位。
一个 c 位数可以写成 c 个元素的元组，耗时 O(c)。
我们对 c 个 n 进制位中的每一位进行排序，每次耗时 O(n)。
因此，使用辅助计数排序的元组排序总运行时间为 O(cn)。
如果 c 是常数（即每个键值 ≤ $n^c$），这个排序算法就是线性时间 O(n)！
```python
def radix_sort(A):
    "Sort A assuming items have non-negative keys"
    n = len(A)
    u = 1 + max([x.key for x in A])          # O(n) 找到最大键值
    c = 1 + (u.bit_length() // n.bit_length())  # 计算位数 c

    class Obj: pass
    D = [Obj() for a in A]                   # O(nc) 创建数字元组
    for i in range(n):
        D[i].digits = []
        D[i].item = A[i]
        high = A[i].key
        for j in range(c):                   # O(c) 创建数字元组
            high, low = divmod(high, n)
            D[i].digits.append(low)

    for i in range(c):                       # O(nc) 对每一位进行排序
        for j in range(n):                   # O(n) 为元组分配第 i 位作为键值
            D[j].key = D[j].digits[i]
        counting_sort(D)                     # O(n) 对第 i 位排序

    for i in range(n):                       # O(n) 输出到 A
        A[i] = D[i].item
```
|算法|时间复杂度|原地排序|稳定|备注|
| :---: | :---: | :---: | :---: | :---: |
|插入排序|O(n²)|Y|Y|对近似有序的 k-近序数组为 O(nk)|
|选择排序|O(n²)|Y|N|只需 O(n) 次交换|
|归并排序|O(n log n)|N|Y|稳定的，比较排序中最优|
|计数排序|O(n + u)|N|Y|当 u = O(n) 时为 O(n)|
|基数排序|O($n log_n(u)$)|N|Y|当 u = O($n^c$)（c为常数）时为 O(n)|
___
[返回目录](#目录)
___
## Lecture 6: Binary Trees I<a id = "l6"></a>
### 1. 二叉树
基于指针的数据结构（如链表）可以实现最坏情况性能
二叉树是基于指针的数据结构，每个节点有三个指针
节点表示：node.{item, parent, left, right}
二叉树示例
```text
        <A>
      /     \
    <B>     <C>
   /   \
 <D>   <E>
 /
<F>
```
节点表示：
```text
节点 | 项目 | 父节点 | 左孩子 | 右孩子
<A> |   A  |   -   |  <B>  |  <C>
<B> |   B  |  <A>  |  <D>  |  <E>
<C> |   C  |  <A>  |   -   |   -
<D> |   D  |  <B>  |  <F>  |   -
<E> |   E  |  <B>  |   -   |   -
<F> |   F  |  <D>  |   -   |   -
```
术语
根：没有父节点的节点（例如：`<A>`）
叶节点：没有子节点的节点（例如：`<C>`、`<E>`、`<F>`）
深度：从节点 `<X>` 到根 `<R>` 的路径长度
高度：以节点 `<X>` 为根的子树中任意节点的最大深度
设计目标：使操作在 O(h) 时间内运行（h 是根的高度），并保持 h = O(log n)
### 2. 遍历顺序
二叉树具有固有的遍历顺序：
节点 `<X>` 左子树中的所有节点都在 `<X>` 之前
节点 `<X>` 右子树中的所有节点都在 `<X>` 之后
通过从根开始的递归算法按遍历顺序列出节点：
递归列出左子树，列出自身，然后递归列出右子树
运行时间为 O(n)，因为列出每个节点需要 O(1) 的工作
示例：遍历顺序为 (`<F>`, `<D>`, `<B>`, `<E>`, `<A>`, `<C>`)
当前，遍历顺序相对于存储的项目没有特定含义
之后，将为遍历顺序分配语义含义，以实现序列/集合接口
### 3. 树导航
查找子树中的第一个节点（最后一个节点对称）：
如果 `<X>` 有左孩子，则递归返回左子树中的第一个节点
否则，`<X>` 就是第一个节点，返回它
运行时间：O(h)，其中 h 是树的高度
示例：`<A>` 子树中的第一个节点是 `<F>`
查找节点 `<X>` 的后继节点（前驱节点对称）：
如果 `<X>` 有右孩子，则返回右子树中的第一个节点
否则，返回 `<X>` 的最低祖先，使得 `<X>` 在该祖先的左子树中
运行时间：O(h)，其中 h 是树的高度
示例：后继节点：`<B>` 是 `<E>`，`<E>` 是 `<A>`，`<C>` 是 None
### 4. 动态操作
通过单个项目更改树（仅添加或删除叶节点）：
在遍历顺序中在另一个节点之后添加节点（之前对称）
从树中删除一个项目
在遍历顺序中将节点 `<Y>` 插入到节点 `<X>` 之后：
如果 `<X>` 没有右孩子，则使 `<Y>` 成为 `<X>` 的右孩子
否则，使 `<Y>` 成为 `<X>` 后继节点的左孩子（该后继节点不能有左孩子）
运行时间：O(h)
示例：在遍历顺序中将节点 `<G>` 插入到 `<E>` 之前
```text
     <A>              <A>
    /   \            /   \
  <B>   <C>   =>   <B>   <C>
  / \              / \
<D> <E>          <D> <E>
 /                /   /
<F>             <F> <G>
```
示例：在遍历顺序中将节点 `<H>` 插入到 `<A>` 之后
```text
     <A>                <A>
    /   \              /   \
  <B>   <C>    =>    <B>   <C>
  / \                / \     \
<D> <E>            <D> <E>   <H>
 /   \              /   \
<F> <G>           <F>   <G>
```
从子树中删除节点 `<X>` 中的项目：
如果 `<X>` 是叶节点，则从父节点分离并返回
否则，`<X>` 有一个孩子
如果 `<X>` 有左孩子，则与 `<X>` 的前驱交换项目并递归
否则 `<X>` 有右孩子，则与 `<X>` 的后继交换项目并递归
运行时间：O(h)
示例：删除 `<F>`（叶节点）
```text
     <A>                <A>
    /   \              /   \
  <B>   <C>    =>    <B>   <C>
  / \     \          / \     \
<D> <E>   <H>      <D> <E>   <H>
 /   \                \
<F> <G>               <G>
```
示例：删除 `<A>`（非叶节点，因此首先向下交换到叶节点）
```text
     <A>                <E>                <E>
    /   \              /   \              /   \
  <B>   <C>    =>    <B>   <C>    =>    <B>   <C>
  / \     \          / \     \          / \     \
<D> <E>   <H>      <D> <G>   <H>      <D> <G>   <H>
    /                    /
  <G>                  <A>
```
### 4. 应用：集合（二叉搜索树 BST）
思路！集合二叉树（二叉搜索树 BST）：
遍历顺序是按键值递增的排序顺序
等价于 BST 性质：对于每个节点，左子树中的所有键值 ≤ 节点的键值 ≤ 右子树中的所有键值
然后可以像二分查找一样在 O(h) 时间内查找子树中键值为 k 的节点：
如果 k 小于 `<X>` 的键值，则递归到左子树（或返回 None）
如果 k 大于 `<X>` 的键值，则递归到右子树（或返回 None）
否则，返回存储在 `<X>` 处的项目
其他集合操作遵循类似模式；
### 5. 应用：序列
思路！序列二叉树：遍历顺序是序列顺序
如何查找子树遍历顺序中的第 i 个节点？ 将此操作称为 subtree_at(i)
可以遍历整个遍历顺序，但这样不好，O(n)
但是，如果能在 O(1) 时间内计算子树的大小，则可以在 O(h) 时间内解决
如何实现？检查左子树的大小 nL 并与 i 比较
如果 i < nL，则递归到左子树
如果 i > nL，则递归到右子树，使用 i' = i - nL - 1
否则，i = nL，即已达到所需节点！
通过增强在每个节点处维护其子树的大小
为每个节点添加 node.size 字段
添加新叶节点时，为所有祖先 a 的 a.size 加 1，时间 O(h)
删除叶节点时，为所有祖先 a 的 a.size 减 1，时间 O(h)
序列操作直接源自快速的 subtree_at(i) 操作
朴素的 build(X) 需要 O(nh) 时间，但可以在 O(n) 时间内完成；
目前为止的总结
![p6](./笔记插图集/p6.png)
___
[返回目录](#目录)
___
## Lecture 7: Binary Trees II<a id = "l7"></a>
### 1. 高度平衡
如何维持树的高度 h = O(log n)，其中 n 是树中节点的数量？
在执行动态操作后保持 O(log n) 高度的二叉树称为 平衡树
有许多平衡方案（红黑树、伸展树、2-3 树……）
第一个提出的平衡方案是 AVL 树（Adelson-Velsky 和 Landis，1962）
### 2. 旋转操作
需要在不改变遍历顺序的前提下降低树的高度
这意味着我们仍然表示相同的项目序列
如何操作？旋转！
```text
        _____<D>__                __<B>_____
      __<B>__    <E>             <A>     __<D>__
     <A>    <C>        =>  <=           <C>   <E>
rotate_right(<D>)              rotate_left(<B>)
```
一个旋转通过重新链接 O(1) 个指针来修改树的结构，同时保持遍历顺序不变
旋转足以实现所有变换
声明：O(n) 次旋转可以将一棵二叉树转换为任何其他具有相同遍历顺序的二叉树
证明：
重复执行遍历顺序中最后可能进行的右旋
得到的树是一个规范的链（所有节点只有右孩子）
每次旋转使最后一个节点的深度增加 1
最终链中最后一个节点的深度为 n-1，因此最多执行 n-1 次旋转
反向旋转可以到达目标树
可以使用 O(n) 次旋转来完全平衡树，但太慢
我们需要在 O(log n) 时间 内保持树平衡！
### 3. AVL树：高度平衡
AVL树保持高度平衡（亦称AVL性质）
- 若某节点的左右子树高度差至多为1，则该节点是高度平衡的
- 定义节点的偏斜度为其右子树高度减去左子树高度
- 则当节点的偏斜度为-1、0或1时，该节点是高度平衡的

断言：所有节点均高度平衡的二叉树具有高度 h = O(log n)（即 n = $2^{Ω(h)}$）
证明：只需证明高度为h的树中最少节点数 F(h) 满足 F(h) = $2^{Ω(h)}$
$F(0) = 1, F(1) = 2, F(h) = 1 + F(h-1) + F(h-2) ≥ 2F(h-2) => F(h) ≥ 2^{(h/2)}$
假设在高度平衡的树中添加或移除一个叶子节点导致失衡
仅该叶子祖先节点的子树高度或偏斜度发生变化
高度仅变化±1，因此偏斜度幅值仍≤2
思路：从叶子节点向上依次修复祖先节点的高度平衡
反复对最低的非高度平衡祖先节点进行再平衡（不失一般性，假设其偏斜度为2）
局部再平衡：给定二叉树节点 `<B>`：
- 其偏斜度为2，且
- `<B>`子树中所有其他节点均高度平衡，
- 则通过一次或两次旋转可使`<B>`的子树恢复高度平衡
- （操作后，`<B>`的高度与之前相同或减1）

证明：由于`<B>`偏斜度为2，其右子节点`<F>`存在
1. 情况1：`<F>`的偏斜度为0 或 情况2：`<F>`的偏斜度为1
对`<B>`执行一次左旋
```
      <B>           =>          <F>
     /   \                     /   \
   <A>   <F>                 <B>   <G>
         / \                /   \
       <D> <G>            <A>   <D>
```
设 h = height(`<A>`)。则 height(`<G>`) = h + 1，且 height(`<D>`) 在情况1下为 h+1，在情况2下为 h
旋转后：
- `<B>`的偏斜度在情况1下为1，情况2下为0，因此`<B>`高度平衡
- `<F>`的偏斜度为-1，因此`<F>`高度平衡
- `<B>`之前高度为 h+3，之后在情况1下为 h+3，情况2下为 h+2
2. 情况3：`<F>`的偏斜度为-1，因此其左子节点`<D>`存在
- 先对`<F>`执行一次右旋，再对`<B>`执行一次左旋
```
    <B>                         <D>
   /   \                       /   \
 <A>   <F>                   <B>   <F>
       / \                   / \   / \
     <D> <G>               <A> <C><E> <G>
    / \
  <C> <E>
```
设 h = height(`<A>`)。则 height(`<G>`) = h，且 height(`<C>`) 和 height(`<E>`) 各自为 h 或 h-1
旋转后：
- `<B>`的偏斜度为0或-1，因此`<B>`高度平衡
- `<F>`的偏斜度为0或1，因此`<F>`高度平衡
- `<D>`的偏斜度为0，因此D高度平衡
- `<B>`之前高度为 h+3，之后为 h+2

全局再平衡：在高度平衡树 T 中添加或移除一个叶子节点得到树 T'。则可通过最多 O(log n) 次旋转将 T' 转换为高度平衡树 T''。
证明：仅受影响叶子的祖先节点在 T' 中的高度与在 T 中不同
受影响叶子最多有 h = O(log n) 个祖先，其子树可能已改变
令 `<X>` 为最低的非高度平衡祖先节点（其偏斜度幅值为2）
若在 T 中添加了一个叶子：
- 插入操作增加了`<X>`的高度，因此属于局部再平衡的情况2或3
- 旋转会降低子树高度：一次旋转后即可平衡

若从 T 中移除了一个叶子：
- 删除操作降低了`<X>`的某个子节点的高度，而非`<X>`本身，因此仅导致不平衡
- 可能使`<X>`的高度降低1；`<X>`的父节点现在可能失衡
- 因此可能必须重新平衡`<X>`的每一个祖先，但最多有 h = O(log n) 个这样的节点

因此，插入/删除后仅使用 O(log n) 次旋转即可维持高度平衡！
但这需要我们检查可能多达 O(log n) 个节点是否高度平衡
### 4. 计算高度
如何判断节点`<X>`是否高度平衡？计算子树高度！
如何计算节点`<X>`的高度？朴素算法：
递归计算`<X>`左右子树的高度
取两者最大值加1
运行时间为 Ω(n)，因为我们对每个节点都进行了递归
思路：为每个节点增强存储其子树的高度！（留待稍后详述！）
`<X>`的高度可根据其子节点高度在 O(1) 时间内计算得出：
以 O(1) 时间查找左右子树的存储高度，取两者最大值加1
在动态操作期间，当树形结构变化时，我们必须维护我们的增强信息
为每个子树发生变化的节点重新计算子树增强信息：
在旋转操作中以 O(1) 时间更新被重新链接的节点（其祖先不变）
通过向上遍历树，以 O(h) 时间更新插入或删除节点的所有祖先
### 5. 增强二叉树的步骤
通常，要为二叉树增强一个子树属性 P，你必须：
- 说明你想在每个节点`<X>`存储的子树属性 P(`<X>`)
- 展示如何在 O(1) 时间内根据`<X>`子节点的增强信息计算出 P(`<X>`)

这样，存储的属性 P(`<X>`) 可以在不改变动态操作成本的前提下得到维护
### 6. 应用：序列
对于序列二叉树，我们需要知道子树大小
仅插入/删除叶子时，这很容易，但现在需要处理旋转
子树大小是一个子树属性，因此可以通过增强来维护——可以通过将子节点的大小相加再加1来计算大小
集合AVL树对所有集合操作实现 O(lg n) 时间，除了构建操作为 O(n log n) 时间和迭代操作为 O(n) 时间
序列AVL树对所有序列操作实现 O(lg n) 时间，除了构建和迭代操作为 O(n) 时间
### 7. 应用：排序
任何集合数据结构都定义了一种排序算法：构建（或重复插入）然后迭代
例如，讲座5中的直接访问数组排序
AVL排序是一种新的 O(n lg n) 时间排序算法
___
[返回目录](#目录)
___
## Lecture 8: Binary Heaps<a id = "l8"></a>
### 1. 优先队列接口
追踪多个项目，快速访问/删除最重要的项目
根据键（优先级）对项目排序，因此是集合接口（而非序列接口）
针对集合操作的特定子集进行优化：
build(X)：从可迭代对象X构建优先队列
insert(x)：将项目x添加到数据结构
find_max()：返回具有最大键的已存储项目
delete_max()：移除并返回具有最大键的已存储项目
（通常针对最大值或最小值进行优化，而非两者兼顾）
重点关注插入和删除最大值操作：构建可以通过重复插入实现；find_max()可以通过insert(delete_min())实现
### 2. 优先队列排序
任何优先队列数据结构都可以转化为排序算法：
build(A)，例如，按输入顺序逐个插入项目
重复调用delete_min()（或delete_max()）来确定（反向）排序顺序
所有复杂工作都在数据结构内部完成
运行时间为 $T_{build}$ + $n · T_{delete\_max}$ ≤ $n · T_{insert}$ + $n · T_{delete\_max}$
我们见过的许多排序算法都可以视为优先队列排序：
![p7](./笔记插图集/p7.png)
### 3. 优先队列：集合AVL树
集合AVL树支持insert(x), find_min(), find_max(), delete_min(), delete_max()，每个操作时间复杂度为O(log n)
因此优先队列排序的运行时间为O(n log n) — 这本质上是第7讲的AVL排序
可以通过子树增强技术将find_min()和find_max()加速到O(1)时间
但这种数据结构复杂，且由此产生的排序不是原地的
是否有更简单的数据结构专门用于优先队列，并能进行原地O(n lg n)排序？
有的，二叉堆和堆排序
本质上是利用我们学过的二叉树知识，在序列数据结构（数组）之上实现集合数据结构
### 4. 优先队列：数组（无序）
将元素存储在无序动态数组中
insert(x)：以摊销O(1)时间将x追加到末尾
delete_max()：O(n)时间查找最大值，将最大值交换到末尾并移除
插入快，但删除最大值慢
优先队列排序就是选择排序！（外加一些复制操作）
### 5. 优先队列：有序数组
将元素存储在有序动态数组中
insert(x)：将x追加到末尾，以O(n)时间交换到排序位置
delete_max()：以摊销O(1)时间从末尾删除
删除最大值快，但插入慢
优先队列排序就是插入排序！（外加一些复制操作）
我们能否在这两种极端的数组优先队列之间找到一个折中方案？
### 6. 作为完全二叉树的数组
想法：将数组解释为一棵完全二叉树，除最深一层外，深度 i 处最多有 $2^i$ 个节点，且最深一层的节点都左对齐
等价地说，完全树按读取顺序密集填充：从根到叶，从左到右
视角：数组和完全二叉树之间存在一一对应关系
包含n个项目的数组的完全二叉树表示的高度是 ⌈lg n⌉，因此是平衡二叉树
### 7. 隐式完全树
完全二叉树结构可以是隐式的，无需存储指针
根位于索引0
通过索引算术计算邻居：
left(i) = 2i + 1
right(i) = 2i + 2
parent(i) = ⌊(i − 1)/2⌋
### 8. 二叉堆
想法：使较大的元素在树中保持较高位置，但仅限于局部
节点i处的最大堆性质：对于所有 j ∈ {left(i), right(i)}，有 Q[i] ≥ Q[j]
最大堆是一个在所有节点上都满足最大堆性质的数组
断言：在最大堆中，对于所有节点i及其子树中的所有节点j，满足 Q[i] ≥ Q[j]
证明：对深度差 d = depth(j) − depth(i) 进行归纳
### 9. 堆插入
以摊销O(1)时间将新项目x追加到数组末尾，使其成为读取顺序中的下一个叶子节点i
max_heapify_up(i)：与父节点交换，直到满足最大堆性质
检查是否满足 Q[parent(i)] ≥ Q[i]（这是父节点处最大堆性质的一部分）
如果不满足，交换 Q[i] 和 Q[parent(i)]，并递归地对 parent(i) 调用 max_heapify_up
正确性：最大堆性质保证了所有节点 ≥ 其后代，但Q[i]可能大于其某些祖先（除非i是根节点，此时结束）。如果需要交换，同样的保证条件对于 Q[parent(i)] 成立。
运行时间：树的高度，即 Θ(log n)!
### 10. 堆删除最大值
只能轻松地从动态数组中移除最后一个元素，但最大键位于树的根节点
因此，将根节点 i=0 处的项目与堆数组中最后一个节点 n-1 处的项目交换
max_heapify_down(i)：将根节点与较大的子节点交换，直到满足最大堆性质
检查对于 j ∈ {left(i), right(i)}，是否满足 Q[i] ≥ Q[j]（节点i处的最大堆性质）
如果不满足，将 Q[i] 与具有最大键的子节点 j ∈ {left(i), right(i)} 进行交换，并递归地对 j 调用 max_heapify_down
正确性：最大堆性质保证了所有节点 ≥ 其后代，但Q[i]可能小于其某些后代（除非i是叶子节点，此时结束）。如果需要交换，同样的保证条件对于 Q[j] 成立。
运行时间：树的高度，即 Θ(log n)!
### 11. 堆排序
将最大堆应用到优先队列排序中，我们得到一种新的排序算法
运行时间为O(n log n)，因为每次插入和删除最大值操作都是O(log n)
但通常对此排序算法进行两项改进：
### 12. 原地优先队列排序
最大堆Q是一个更大数组A的前缀，记录有多少项目|Q|属于堆
|Q|初始为0，最终变为|A|（插入后），然后再变为0（删除后）
insert()：将数组中索引|Q|处的下一个项目吸收到堆中
delete_max()：将最大项目移到末尾，然后通过递减|Q|来丢弃它
使用Array的原地优先队列排序正是选择排序
使用Sorted Array的原地优先队列排序正是插入排序
使用二叉最大堆的原地优先队列排序就是堆排序
### 13. 线性建堆
将n个项目插入堆中对 i 从 0 到 n-1（从上到下）调用 max_heapify_up(i)：
$∑_{i=0}^{n-1} depth(i) ≈ ∑_{i=0}^{n-1} lg i = lg(n!) ≥ (n/2) lg(n/2) = Ω(n lg n)$
想法！从一开始就将整个数组视为完全二叉树，然后对 i 从 n-1 到 0（从下到上）调用 max_heapify_down(i)：
$∑_{i=0}^{n-1} height(i) ≈ ∑_{i=0}^{n-1} (lg n - lg i) = lg(n^n / n!) = Θ(lg(n^n / (n/e)^n)) = O(n)$
因此可以在O(n)时间内建堆
（这并不会加快O(n lg n)的堆排序性能）
### 14. 序列AVL树优先队列
我们在哪里见过对数级数据结构的线性构建时间？序列AVL树！
以任意顺序（插入顺序）将优先队列项目存储在序列AVL树中
维护最大值（和/或最小值）增强：
node.max：指向节点子树中具有最大键的节点的指针
这是一个子树属性，因此维护的开销是常数因子
find_min()和find_max()时间为O(1)
delete_min()和delete_max()时间为O(log n)
build(A)时间为O(n)
与二叉堆具有相同的边界（甚至更多）
### 15. 集合 vs. 多重集合
虽然我们的集合接口假设没有重复键，但我们可以使用这些集合来实现允许具有重复键项目的多重集合：
集合中的每个项目是一个序列（例如，链表），存储具有相同键（作为该序列的键）的多重集合项目。
事实上，不经过这种转换，二叉堆和AVL树可以直接用于具有重复键的项目（例如，delete_max会删除某个具有最大键的项目），只需注意使用 ≤ 约束（而非集合AVL树中的 <）。
___
[返回目录](#目录)
___
## Lecture 9: Breadth-First Search<a id = "l9"></a>
### 1. 图的应用
为什么重要？ 图无处不在！
任何网络系统都与图有直接联系
例如：道路网络、计算机网络、社交网络
任何离散系统的状态空间都可以用转移图表示
例如：拼图游戏和棋盘游戏（如国际象棋、俄罗斯方块、魔方）
例如：应用程序工作流、规范说明
### 2. 图的定义
![p8](./笔记插图集/p8.png)
- 图 G = (V, E) 是顶点集合 V 和顶点对集合 E ⊆ V × V 的组合
- 有向边 是有序对，例如对于 u, v ∈ V 的 (u, v)
- 无向边 是无序对，例如对于 u, v ∈ V 的 {u, v}，即 (u, v) 和 (v, u) 相同

在本课程中，我们假设所有图都是简单图：
边是唯一的，例如 (u, v) 在 E 中只出现一次（尽管 (v, u) 可能出现），且
边是不同顶点之间的对，例如对于所有 (u, v) ∈ E 有 u ≠ v
简单图意味着 |E| = O(|V|²)，因为对于无向图 |E| ≤ C(|V|, 2)，对于有向图 ≤ 2C(|V|, 2)
### 3. 邻居集合/邻接关系
- 顶点 u ∈ V 的出邻居集合是 Adj⁺(u) = {v ∈ V | (u, v) ∈ E}
- 顶点 u ∈ V 的入邻居集合是 Adj⁻(u) = {v ∈ V | (v, u) ∈ E}
- 顶点 u ∈ V 的出度是 deg⁺(u) = |Adj⁺(u)|
- 顶点 u ∈ V 的入度是 deg⁻(u) = |Adj⁻(u)|
- 对于无向图，Adj⁻(u) = Adj⁺(u) 且 deg⁻(u) = deg⁺(u)
- 省略上标默认为出邻居，即 Adj(u) = Adj⁺(u) 且 deg(u) = deg⁺(u)
### 4. 图的表示方法
要存储图 G = (V, E)，我们需要存储所有 u ∈ V 的出边 Adj(u)
首先，需要一个集合数据结构 Adj 来映射 u 到 Adj(u)
然后对于每个 u，需要将 Adj(u) 存储在另一个称为邻接表的数据结构中
通常使用直接访问数组或哈希表作为 Adj，因为需要快速通过顶点查找
通常对每个 Adj(u) 使用数组或链表，因为通常只需要迭代
对于常见的表示方法，Adj 的大小为 Θ(|V|)，而每个 Adj(u) 的大小为 Θ(deg(u))
由于握手引理：$∑_{u∈V} deg(u) ≤ 2|E|$，图可存储在 Θ(|V| + |E|) 空间中
因此，对于图的算法，线性时间将意味着 Θ(|V| + |E|)（与图大小成线性关系）

### 5. 示例
示例1和2假设顶点标记为 {0, 1, ..., |V|-1}，因此可以对 Adj 使用直接访问数组，并将 Adj(u) 存储在数组中。示例3使用哈希表作为 Adj。
```
Ex 1 (Undirected) | Ex 2 (Directed) | Ex 3 (Undirected)
G1 = [            | G2 = [           | G3 = [
[2, 1], # 0       | [2], # 0         | a: [s, b], b: [a],
[2, 0, 3], # 1    | [2, 0], # 1      | s: [a, c], c: [s, d, e],
[1, 3, 0], # 2    | [1], # 2         | d: [c, e, f], e: [c, d, f],
[1, 2], # 3       | ]                | f: [d, e], g: []
]                 |                  | ]
```
注意，在无向图中，连接是对称的，因为每条边都作为出边出现两次
每个 Adj(u) 使用哈希表可以在 O(1)(e) 时间内检查边 (u, v) ∈ E
### 6. 路径
路径是顶点序列 p = (v₁, v₂, ..., vₖ)，其中对于所有 1 ≤ i < k 有 (vᵢ, vᵢ₊₁) ∈ E
如果路径不重复顶点，则称其为简单路径
路径 p 的长度 ℓ(p) 是路径中边的数量
从 u ∈ V 到 v ∈ V 的距离 δ(u, v) 是从 u 到 v 的任何路径的最小长度，即从 u 到 v 的最短路径的长度（按惯例，如果 u 不连接到 v，则 δ(u, v) = ∞）
### 7. 图路径问题
关于图中的路径，你可能想解决许多问题：
- 单对可达性(G, s, t)：在图 G 中是否存在从 s ∈ V 到 t ∈ V 的路径？
- 单对最短路径(G, s, t)：返回距离 δ(s, t)，以及图 G = (V, E) 中从 s ∈ V 到 t ∈ V 的最短路径
- 单源最短路径(G, s)：返回所有 v ∈ V 的 δ(s, v)，以及包含从 s 到每个 v ∈ V 的最短路径的最短路径树（定义如下）

上述每个问题至少比其上方的问题更难（即，你可以使用解决较低问题的黑盒来解决任何较高问题）
我们不会展示解决所有这些问题的算法，而是展示一种在 O(|V| + |E|) 时间内解决最难问题的算法！
### 8. 最短路径树
如何为图中的每个顶点返回从源顶点 s 出发的最短路径？
许多路径可能具有长度 Ω(|V|)，因此返回每条路径可能需要 Ω(|V|²) 时间
相反，对于所有 v ∈ V，存储其父节点 P(v)：从 s 出发的最短路径上倒数第二个顶点
令 P(s) 为 null（从 s 到 s 的最短路径上没有倒数第二个顶点）
父节点集合构成一个大小为 O(|V|) 的最短路径树！（即，从每个可以从 s 到达的顶点返回到 s 的反向最短路径）
### 9. 广度优先搜索（BFS）
如何计算所有 v ∈ V 的 δ(s, v) 和 P(v)？
将 δ(s, v) 和 P(v) 存储在集合数据结构中，映射顶点 v 到距离和父节点
（如果从 s 到 v 没有路径，则不将 v 存储在 P 中，并将 δ(s, v) 设为 ∞）
思路！按距离递增的顺序探索图节点
目标：计算层级集合 Lᵢ = {v | v ∈ V 且 d(s, v) = i}（即距离为 i 的所有顶点）
断言：每个顶点 v ∈ Lᵢ 必须与某个顶点 u ∈ Lᵢ₋₁ 相邻（即 v ∈ Adj(u)）
断言：任何在某个 j < i 的 Lⱼ 中的顶点不会出现在 Lᵢ 中
不变式：对于任何 j < i 的 Lⱼ 中的所有 v，δ(s, v) 和 P(v) 都已正确计算
基本情况（i = 1）：L₀ = {s}，δ(s, s) = 0，P(s) = None
归纳步骤：要计算 Lᵢ：
对于 Lᵢ₋₁ 中的每个顶点 u：
对于每个顶点 v ∈ Adj(u)，且不出现在任何 j < i 的 Lⱼ 中：
将 v 添加到 Lᵢ，设置 δ(s, v) = i，并设置 P(v) = u
不断增加 i，从 j < i 的 Lⱼ 计算 Lᵢ，直到 Lᵢ 为空集
对于任何未设置 δ(s, v) 的 v ∈ V，设置 δ(s, v) = ∞
广度优先搜索通过归纳正确计算所有 δ(s, v) 和 P(v)
运行时间分析：
将每个 Lᵢ 存储在具有 Θ(|Lᵢ|) 时间迭代和 O(1) 时间插入的数据结构中（即动态数组或链表）
通过检查 v 是否在 P 中，可以检查顶点 v 是否在任意 j < i 的 Lⱼ 中
将 δ 和 P 维护在支持 O(1) 时间字典操作的集合数据结构中（即直接访问数组或哈希表）
算法将每个顶点 u 添加到 ≤ 1 个层级中，并为每个 v ∈ Adj(u) 花费 O(1) 时间
握手引理保证工作量上限为$O(1) × ∑_{u∈V} deg(u) = O(|E|)$
最后花费 Θ(|V|) 时间为从 s 不可达的顶点 v ∈ V 分配 δ(s, v)
因此广度优先搜索以线性时间运行！O(|V| + |E|)
___
[返回目录](#目录)
___
## Lecture 10: Depth-First Search<a id = "l10"></a>
### 1. 深度优先搜索（DFS）
搜索图的方式与广度优先搜索（BFS）类似，从一个顶点s开始。
解决单源可达性问题，而非单源最短路径问题。对于解决其他问题（后续会介绍！）非常有用。
返回一个（不一定是距离最短的）指向源点s的父指针树。
核心思想：递归地访问出边邻接点，但绝不重复访问同一个顶点。
即，沿着任意路径前进直到无法继续，然后回溯直到找到一条未探索的路径继续探索。
设置 P(s) = None，然后运行 visit(s)，其中：
visit(u)：
对于每个 v ∈ Adj(u) 且 v 不在 P 中：
设置 P(v) = u 并递归调用 visit(v)。
（DFS完成了对顶点u的访问，这将在后续使用！）
### 2. 正确性
断言：对于从 s 可达的每一个顶点 v，DFS 都会访问 v 并正确设置 P(v)。
证明：基于距离 k 进行归纳，该断言仅针对距离 s 为 k 的顶点。
基本情况 (k = 0)：为 s 正确设置了 P(s) 并访问了 s。
归纳步骤：考虑顶点 v，其 δ(s, v) = $k_0$ + 1。
考虑顶点 u，它是从 s 到 v 的某条最短路径上的倒数第二个顶点。
根据归纳假设，因为 δ(s, u) = k0，DFS 会访问 u 并正确设置 P(u)。
在访问 u 时，DFS 会考虑 v ∈ Adj(u)。
要么 v 已经在 P 中（即已被访问过），要么在访问 u 的过程中会被访问。
无论哪种情况，v 都会被 DFS 访问，并且会被正确地添加到 P 中。
### 3. 运行时间
算法最多访问每个顶点 u 一次，并对每个 v ∈ Adj(u) 花费 O(1) 时间。
工作量上限为 O(1) × ∑ deg(u) = O(|E|)。
与 BFS 不同，DFS 不为每个顶点返回距离值，因此 DFS 的运行时间为 O(|E|)。
### 4. 全图BFS与全图DFS
假设需要探索整个图，而不仅仅是从一个顶点出发可达的顶点。
思路：在任何未访问的顶点上重复执行图搜索算法 A。
重复以下步骤直到所有顶点都被访问：
选择一个任意的未访问顶点 s，使用算法 A 探索所有从 s 可达的顶点。
我们称此算法为 Full-A，特别是当 A 是 BFS 或 DFS 时，称为 Full-BFS 或 Full-DFS。
会访问每个顶点一次，因此 Full-BFS 和 Full-DFS 的运行时间均为 O(|V| + |E|)。
### 5. 图连通性
如果一个无向图中每对顶点之间都存在一条路径，则该图是连通的。
在有向图中，顶点 u 可能从 v 可达，但 v 可能从 u 不可达。
对于有向图，连通性问题更为复杂（本课程不讨论）。
连通性判断：判断无向图 G 是否连通。
连通分量：给定无向图 G = (V, E)，返回将 V 划分为若干子集 Vi ⊆ V（即连通分量）的结果，其中每个 Vi 在 G 中是连通的，并且不同连通分量中的顶点之间没有边。
考虑一个解决单源可达性问题的图算法 A。
断言：A 可用于解决连通分量问题。
证明：运行 Full-A。对于每次运行 A，将访问到的顶点放入一个连通分量中。
### 6. 拓扑排序
有向无环图 是指不包含有向环的有向图。
图 G = (V, E) 的一个拓扑序 是一个定义在顶点上的排序 f，使得：对于每条边 (u, v) ∈ E，都满足 f(u) < f(v)。
如何找到一个拓扑序？
完成顺序 是 Full-DFS 完成访问 G 中每个顶点的顺序。
断言：如果 G = (V, E) 是一个 DAG，则其完成顺序的逆序就是一个拓扑序。
证明：需要证明对于每条边 (u, v) ∈ E，u 排在 v 之前，即对 v 的访问在访问 u 之前完成。分两种情况：
如果 u 在 v 之前被访问：
在对 u 的访问完成之前，将会访问 v（通过边 (u, v) 或其他方式）。
因此，对 v 的访问完成于对 u 的访问完成之前。
如果 v 在 u 之前被访问：
由于图是无环的，u 不可能从 v 可达。
因此，对 v 的访问完成于对 u 的访问完成之前。
### 7. 环检测
如果图 G = (V, E) 是无环的，Full-DFS 将找到一个拓扑序。
如果 Full-DFS 的逆完成顺序不是拓扑序，那么 G 必定包含环。
检查 G 是否无环：对于每条边 (u, v)，检查在逆完成顺序中 v 是否排在 u 之前。可以通过哈希表或直接访问数组在 O(|E|) 时间内完成。
为了返回这样一个环，在 Full-DFS 中维护沿着路径回溯到源点 s 的祖先集合。
断言：如果 G 包含环，Full-DFS 将遍历一条从某个顶点 v 指向其某个祖先的边。
证明：考虑 G 中的一个环 (v0, v1, ..., vk, v0)。
不失一般性，设 v0 是 Full-DFS 在该环上访问的第一个顶点。
对于每个 vi，在对 vi 的访问完成之前，将会访问 vi+1 并完成。
将考虑边 (vi, vi+1)，如果 vi+1 未被访问过，此时它将被访问。
因此，在对 v0 的访问完成之前，将会（通过 v0 的假设，是首次）访问 vk。
所以，在对 vk 的访问完成之前，将考虑边 (vk, v0)，而 v0 是 vk 的一个祖先。
___
[返回目录](#目录)
___
## Lecture 11: Weighted Shortest Paths<a id = "l11"></a>
### 1. 加权图
加权图 是一个图 G = (V, E) 连同权重函数 w：E → Z。
即，为每条边 e = (u, v) ∈ E 分配一个整数权重：w(e) = w(u, v)。
图中的边权重有许多应用：
- 道路网络中的距离
- 网络连接中的延迟
- 社交网络中关系的强度

在计算中表示权重的两种常见方法：
在图表示内部：在邻接列表中为每个顶点存储边权重
存储一个单独的集合数据结构，将每条边映射到其权重
我们假设有一种表示方式，可以在 O(1) 时间内查询边的权重。
![p9](./笔记插图集/p9.png)
### 2. 加权路径
加权图中路径 π 的权重 w(π) 是路径中所有边的权重之和。
从 s ∈ V 到 t ∈ V 的（加权）最短路径是从 s 到 t 权重最小的路径。
δ(s, t) = inf{w(π) | 从 s 到 t 的路径 π} 是从 s 到 t 的最短路径权重。
（在加权图中，常使用“距离”表示最短路径权重，而不是边的数量）。
与无权图类似：
如果从 s 到 t 没有路径，则 δ(s, t) = ∞
最短路径的子路径也是最短路径（否则可以拼接进更短的路径）
为什么用下确界（infimum）而不是最小值？可能不存在有限长度的最小权重路径。
何时发生？当图中存在负权重环时可能发生。例如：G1 中的 (b, f, g, c, b)。
负权重环 是指一个起点和终点相同的路径 π，满足 w(π) < 0。
如果存在一条从 s 到 t 的路径经过一个负权重环上的顶点，则 δ(s, t) = −∞。
如果发生这种情况，我们不（总能）得到一条最短路径，但可能希望找到这个负权重环。
### 3. 加权最短路径算法
我们已经知道一种算法：广度优先搜索！当满足特定条件时，在 O(|V| + |E|) 时间内运行，例如：
图具有正权重，且所有权重相同
图具有正权重，且所有权重之和不超过 O(|V| + |E|)
对于一般的加权图，我们不知道如何在 O(|V| + |E|) 时间内解决单源最短路径问题。
但如果你的图是有向无环图，你就可以！
![p10](./笔记插图集/p10.png)
### 4. 最短路径树
对于 BFS，我们在搜索过程中跟踪父指针。或者，可以在之后计算它们！
如果知道所有顶点 v ∈ V 的 δ(s, v)，可以在 O(|V| + |E|) 时间内构建最短路径树。
对于从 s 出发的加权最短路径，只需要为 δ(s, v) 有限的顶点 v 设置父指针。
初始化空的 P，并设置 P(s) = None。
对于每个 δ(s, v) 有限的顶点 u ∈ V：
对于每个出边邻接点 v ∈ Adj+(u)：
如果 P(v) 尚未分配且 δ(s, v) = δ(s, u) + w(u, v)：
存在一条经过边 (u, v) 的最短路径，因此设置 P(v) = u。
父指针可能会遍历权重为零的环。标记此类环中的每个顶点。
对于每个未标记的顶点 u ∈ V（包括后来被取消标记的顶点）：
对于每个 v ∈ Adj+(u)，其中 v 被标记且 δ(s, v) = δ(s, u) + w(u, v)：
通过从 v 开始遍历父指针，取消标记包含 v 的环中的顶点。
设置 P(v) = u，从而打破该环。
因为我们可以随后计算父指针，所以我们将重点放在计算距离上。
### 5. DAG松弛算法
思路！为每个顶点 v ∈ V 维护一个距离估计值 d(s, v)（初始为 ∞），它总是真实距离 δ(s, v) 的上界，然后逐渐降低直到 d(s, v) = δ(s, v)。
何时降低？当一条边违反三角不等式时！
三角不等式：从 u 到 v 的最短路径权重不可能大于从 u 经另一顶点 x 到 v 的最短路径权重，即对于所有 u, v, x ∈ V，δ(u, v) ≤ δ(u, x) + δ(x, v)。
如果对于某条边 (u, v) 有 d(s, v) > d(s, u) + w(u, v)，则违反了三角不等式
通过将 d(s, v) 降低为 d(s, u) + w(u, v) 来修正，即对边 (u, v) 进行松弛，以满足被违反的约束。
断言：松弛操作是安全的：它始终保持每个 d(s, v) 是到达 v 的某条路径的权重（或 ∞），∀v ∈ V。
证明：假设对于所有 v0 ∈ V，d(s, v0) 是某条路径的权重（或 ∞）。松弛某条边 (u, v) 会将 d(s, v) 设置为 d(s, u) + w(u, v)，这是通过 u 从 s 到 v 的一条路径的权重。
### 6. DAG松弛算法步骤
对所有 v ∈ V 设置 d(s, v) = ∞，然后设置 d(s, s) = 0。
按照图 G 的拓扑排序顺序处理每个顶点 u：
对于每个出边邻接点 v ∈ Adj+(u)：
如果 d(s, v) > d(s, u) + w(u, v)：
松弛边 (u, v)，即设置 d(s, v) = d(s, u) + w(u, v)。
### 7. 正确性
断言：在 DAG 松弛算法结束时：对于所有 v ∈ V，d(s, v) = δ(s, v)。
证明：基于 k 进行归纳：对于拓扑序中前 k 个顶点中的所有 v，d(s, v) = δ(s, v)。
基本情况：顶点 s 以及拓扑序中在 s 之前的每个顶点，在开始时都满足断言。
归纳步骤：假设断言对前 k0 个顶点成立，令 v 为第 (k0 + 1) 个顶点。
考虑一条从 s 到 v 的最短路径，并令 u 为路径上 v 的前驱顶点。
u 在拓扑序中位于 v 之前，因此根据归纳假设，d(s, u) = δ(s, u)。
当处理 u 时，d(s, v) 被设置为不大于 δ(s, u) + w(u, v) = δ(s, v) 的值。
但由于松弛是安全的，d(s, v) ≥ δ(s, v)，因此 d(s, v) = δ(s, v)。
另一种证明思路：
对于任何顶点 v，DAG 松弛算法设置 d(s, v) = min{d(s, u) + w(u, v) | u ∈ Adj−(v)}。
到达 v 的最短路径必须经过 v 的某个入边邻接点 u。
因此，如果根据归纳假设，对所有 u ∈ Adj−(v) 有 d(s, u) = δ(s, u)，那么 d(s, v) = δ(s, v)。
### 8. 运行时间
初始化耗时 O(|V|)，拓扑排序耗时 O(|V| + |E|)。
额外工作量的上限为 O(1) × ∑ deg(u) = O(|E|)。
总运行时间是线性的，O(|V| + |E|)。
___
[返回目录](#目录)
___
## Lecture 12: Bellman-Ford<a id = "l12"></a>
### 1. 简单最短路径
如果图中包含环和负权重，则可能包含负权重环。
如果图中不包含负权重环，则最短路径是简单的！
断言1：如果 δ(s, v) 是有限的，则存在一条到 v 的简单最短路径。
证明：（反证法）
假设不存在简单最短路径；令 π 是顶点数最少的最短路径。
π 不是简单的，因此 π 中存在一个环 C；C 具有非负权重（否则 δ(s, v) = -∞）。
从 π 中移除 C 形成路径 π'，其顶点数更少且权重 w(π') ≤ w(π)。
由于简单路径不能重复顶点，有限的最短路径最多包含 |V| - 1 条边。
### 2. 负环见证点
k边距离 δk(s, v)：使用 ≤ k 条边的从 s 到 v 的任何路径的最小权重。
思路！为所有 v ∈ V 计算 δ|V|-1(s, v) 和 δ|V|(s, v)。
如果 δ(s, v) ≠ -∞，则 δ(s, v) = δ|V|-1(s, v)，因为最短路径是简单的（或不存在）。
如果 δ|V|(s, v) < δ|V|-1(s, v)：
存在一条更短的非简单路径到 v，因此 δ|V|(s, v) = -∞。
称 v 为一个（负环）见证点。
然而，可能存在一些最短路径权重为 -∞ 的顶点不是见证点。
断言2：如果 δ(s, v) = -∞，则 v 可以从某个见证点到达。
证明：只需证明：每个从 s 可达的负权重环都包含一个见证点。
考虑一个从 s 可达的负权重环 C。
对于 v ∈ C，令 v' ∈ C 表示 C 中 v 的前驱，其中 Σ v∈C w(v', v) < 0。
那么 δ|V|(s, v) ≤ δ|V|-1(s, v') + w(v', v)（右侧是某个顶点数 ≤ |V| 的路径的权重）。
所以 Σ v∈C δ|V|(s, v) ≤ Σ v∈C δ|V|-1(s, v') + Σ v∈C w(v', v) < Σ v∈C δ|V|-1(s, v)。
如果 C 不包含见证点，则对于所有 v ∈ C 有 δ|V|(s, v) ≥ δ|V|-1(s, v)，矛盾。
### 3. Bellman-Ford 算法
思路！使用图复制：创建图的多个副本（或层级）。
|V| + 1 个层级：层级 k 中的顶点 v_k 表示使用 ≤ k 条边从 s 到达顶点 v。
如果边只向更高的层级延伸，得到的图是一个 DAG！
从 G = (V, E) 构造新的 DAG G' = (V', E')：
G' 有 |V|(|V| + 1) 个顶点 v_k，对于所有 v ∈ V 和 k ∈ {0, ..., |V|}。
G' 有 |V|(|V| + |E|) 条边：
对于每个 v ∈ V 和 k ∈ {1, ..., |V|}，有 |V| 条权重为零的边 ($v_{k-1}, v_k$)。
对于每条边 (u, v) ∈ E 和 k ∈ {1, ..., |V|}，有 |V| 条权重为 w(u, v) 的边 ($u_{k-1}, v_k$)。
在 G' 上从 s_0 运行 DAG 松弛算法，计算所有 v_k ∈ V' 的 δ($s_0, v_k$)。
对于每个顶点：设置 d(s, v) = δ($s_0, v_{|V|-1}$)。
对于每个满足 δ($s_0, u_{|V|}$) < δ($s_0, u_{|V|-1}$) 的见证点 u ∈ V：
对于在 G 中从 u 可达的每个顶点 v：
设置 d(s, v) = -∞。
![p11](./笔记插图集/p11.png)
### 4. 正确性
断言3：对于所有 v ∈ V 和 k ∈ {0, ..., |V|}，有 $δ(s_0, v_k) = δ_k(s, v)$。
证明：基于 k 进行归纳：
基本情况：当 k = 0 时，对所有 v ∈ V 成立（从 $s_0$ 可达的唯一点 $v_0$ 是 v = s）。
归纳步骤：假设对所有 k < k_0 成立，证明 k = k_0 时成立。
$$
\begin{aligned}
δ(s_0, v_{k0}) &= min\{ δ(s_0, u_{k0-1}) + w(u_{k0-1}, v_{k0}) | u_{k0-1} ∈ Adj-(v_{k0}) \} \\
&= min\{ {δ(s_0, u_{k0-1}) + w(u, v) | u ∈ Adj-(v)} ∪ {δ(s_0, v_{k0-1})} \}\\
&= min\{ {δ_{k0-1}(s, u) + w(u, v) | u ∈ Adj-(v)} ∪ {δ_{k0-1}(s, v)} \} （根据归纳假设）
= δ_{k0}(s, v)
\end{aligned}
$$
断言4：在 Bellman-Ford 算法结束时，d(s, v) = δ(s, v)。
证明：根据断言3，算法正确计算了所有 v ∈ V 的 δ|V|-1(s, v) 和 δ|V|(s, v)。
如果 δ(s, v) ≠ -∞，则正确设置 d(s, v) = δ|V|-1(s, v) = δ(s, v)。
然后对于从任何见证点可达的顶点 v，设置 d(s, v) = -∞；根据断言2，这是正确的。
### 5. 运行时间
G' 的大小为 O(|V|(|V| + |E|))，构造它也需要同样多的时间。
在 G' 上运行 DAG 松弛算法需要与 G' 大小成线性关系的时间。
对于每个从见证点可达的顶点进行 O(1) 的工作。
寻找见证点的可达性需要 O(|E|) 时间，最多有 O(|V|) 个见证点：总计 O(|V||E|)。
（或者，通过权重为零的边将超级节点 x 连接到见证点，从 x 开始线性搜索。）
在开始时对图进行剪枝，只保留从 s 可达的子图，可得到 O(|V||E|) 时间复杂度的算法。
### 6. 补充：返回负权重环或空间优化
断言5：对于任何见证点 v，最短的 $s_0 - v_|V|$ 路径 π 在 G 中包含一个负权重环。
证明：由于 π 包含 |V| + 1 个顶点，它必须在 G 中至少包含一个环 C。
C 具有负权重（否则，移除 C 可以构造顶点数更少且权重 w(π') ≤ w(π) 的路径 π'，这与 v 是见证点矛盾）。
可以通过仅为每个 k 从 1 到 |V| 存储 δ($s_0, v_{k-1}$) 和 δ($s_0, v_k$)，仅使用 O(|V|) 空间。
传统上，Bellman-Ford 算法每个顶点只存储一个值，在 |V| 轮中尝试松弛每条边；但估计值并不对应于 k 边距离，因此分析起来更复杂。
但这些空间优化方法不返回负权重环。
___
[返回目录](#目录)
___
## Lecture 13: Dijkstra's Algorithm<a id = "l13"></a>
### 1. 非负边权重
思路！将 BFS 的方法推广到加权图：
以源点 s 为中心扩展一个“球体”。
重复地先探索较近的顶点，再探索较远的顶点。
但是，如果事先不知道距离，如何探索较近的顶点呢？
观察1：如果权重非负，则沿最短路径的距离单调递增。
即，如果顶点 u 出现在从 s 到 v 的一条最短路径上，则 δ(s, u) ≤ δ(s, v)。
令 Vx ⊂ V 为从 s 出发距离 ≤ x 的可达顶点的子集。
如果 v ∈ Vx，那么从 s 到 v 的任何最短路径只包含来自 Vx 的顶点。
或许可以一次增长一个顶点来扩展 Vx！（但如果权重很大，对每个 x 都进行扩展会很慢）。
观察2：如果给定顶点按到 s 的距离递增的顺序，则可以快速解决单源最短路径问题。
移除与此顺序相反的边（因为它们不可能参与最短路径）。
如果存在零权重边，可能仍有环：重复地将环坍缩成单个顶点。
使用 DAG 松弛算法在 O(|V| + |E|) 时间内计算每个 v ∈ V 的 δ(s, v)。
### 2. Dijkstra 算法
以著名的荷兰计算机科学家 Edsger Dijkstra 命名（实际上是 D¨ykstra！）。
思路！按照到源点 s 的距离递增的顺序，松弛每个顶点的出边。
思路！使用一个数据结构高效地找到顺序中的下一个顶点。
可变优先级队列 Q：存储具有键值和唯一标识符的项，支持以下操作：
Q.build(X)：用迭代器 X 中的项初始化 Q。
Q.delete_min()：移除具有最小键值的项。
Q.decrease_key(id, k)：找到标识符为 id 的存储项，并将其键值更改为 k。
通过交叉链接一个优先级队列 Q' 和一个将标识符映射到 Q' 中位置的字典 D 来实现。
假设顶点标识符是从 0 到 |V| - 1 的整数，因此可以对 D 使用直接访问数组。
为简洁起见，称项 x 是元组 (x.id, x.key)。
对所有 v ∈ V 设置 d(s, v) = ∞，然后设置 d(s, s) = 0。
构建可变优先级队列 Q，其中包含每个顶点 v ∈ V 的项 (v, d(s, v))。
当 Q 不为空时，从 Q 中删除一个具有最小 d(s, u) 的项 (u, d(s, u))：
![p12](./笔记插图集/p12.png)
对于出边邻接点 v ∈ Adj+(u)：
如果 d(s, v) > d(s, u) + w(u, v)：
- 松弛边 (u, v)，即设置 d(s, v) = d(s, u) + w(u, v)。
- 将 Q 中顶点 v 的键值减少到新的估计值 d(s, v)。
### 3. 正确性
断言：在 Dijkstra 算法结束时，对于所有 v ∈ V，有 d(s, v) = δ(s, v)。
证明：
如果松弛操作将 d(s, v) 设置为 δ(s, v)，那么在算法结束时 d(s, v) = δ(s, v)。
松弛操作只能减少估计值 d(s, v)。
松弛操作是安全的，即保持每个 d(s, v) 是到 v 的某条路径的权重（或 ∞）。
只需证明当顶点 v 从 Q 中移除时，有 d(s, v) = δ(s, v)。
基于前 k 个从 Q 中移除的顶点进行归纳证明。
基本情况 (k = 1)：s 是第一个从 Q 中移除的顶点，且 d(s, s) = 0 = δ(s, s)。
归纳步骤：假设对 k < k0 成立，考虑第 k0 个从 Q 中移除的顶点 v0。
考虑一条从 s 到 v0 的最短路径 π，其权重 w(π) = δ(s, v0)。
令 (x, y) 为路径 π 中第一条满足 y 不在前 k0 - 1 个顶点中的边（可能 y = v0）。
当 x 从 Q 中移除时，根据归纳假设 d(s, x) = δ(s, x)，因此：
$$
\begin{aligned}
d(s, y) &≤ δ(s, x) + w(x, y) \quad 在移除 x 时松弛了边 (x, y) \\
&= δ(s, y) \quad 最短路径的子路径是最短路径 \\
&≤ δ(s, v0) \quad 边权重非负 \\
&≤ d(s, v0) \quad 松弛操作是安全的 \\
&≤ d(s, y) \quad v0 是 Q 中具有最小 d(s, v) 的顶点 \\
\end{aligned}
$$
所以 d(s, v0) = δ(s, v0)，符合预期。
### 4. 运行时间
计算可变优先级队列 Q 上的操作次数，假设其包含 n 个项：
|操作|时间复杂度|在 Dijkstra 中出现次数|
| :---: | :---: | :---: |
|Q.build(X) (n = \|X\|)|$B_n$|1|
|Q.delete_min()|$M_n$|\|V\||
|Q.decrease_key(id, k)|$D_n$|\|E\||

总运行时间为 $O(B_{|V|} + |V| · M_{|V|} + |E| · D_{|V|})$。
假设已对图进行剪枝，只搜索从源点可达的顶点，因此 |V| = O(|E|)。
![p13](./笔记插图集/p13.png)	
如果图是稠密的，即 |E| = Θ(|V|²)，使用数组实现 Q' 可获得 O(|V|²) 的时间复杂度。
如果图是稀疏的，即 |E| = Θ(|V|)，使用二叉堆实现 Q' 可获得 O(|V| log |V|) 的时间复杂度。
斐波那契堆在所有情况下都具有良好的理论时间复杂度，但在实践中使用不多。
在理论问题中，当使用 Dijkstra 算法时，你可以假设其运行时间为 O(|E| + |V| log |V|)。
那么全源最短路径问题呢？
执行 |V| 次单源最短路径算法实际上相当不错，因为输出大小为 O(|V|²)。
对于具有负权重的通用图，可以做得比 |V| · O(|V| · |E|) 更好。
___
[返回目录](#目录)
___
## Lecture 14: Johnson's Algorithm <a id = "l14"></a>
### 1. 全源最短路径（APSP）
输入：带有权重函数 w：E → Z 的有向图 G = (V, E)
输出：所有 u, v ∈ V 的 δ(u, v)，或者如果 G 包含负权重环则中止算法
在理解整个网络时非常有用，例如交通、电路布局、供应链...
仅执行 |V| 次单源最短路径算法实际上相当不错，因为输出大小为 O(|V|²)：
如果权重为正且受 O(|V| + |E|) 限制，使用 BFS 的时间为 |V|·O(|V| + |E|)
如果是无环图，使用 DAG 松弛算法的时间为 |V|·O(|V| + |E|)
如果权重非负或图是无向的，使用 Dijkstra 算法的时间为 |V|·O(|V| log |V| + |E|)
使用 Bellman-Ford 算法（通用情况）的时间为 |V|·O(|V|·|E|)
目标：在任何加权图中，在 |V|·O(|V| log |V| + |E|) 的时间内解决 APSP 问题
### 2. 方法
思路：使所有权重变为非负，同时保持最短路径不变！
即，将 G 重新赋权为 G'，使得 G' 中没有负权重，并且 G 中的最短路径在 G' 中也是最短的。
如果权重非负，那么只需运行 |V| 次 Dijkstra 算法来解决 APSP 问题。
断言：可以从 G' 中的距离计算出 G 中的距离，时间复杂度为 O(|V|(|V| + |E|))。
根据距离计算最短路径树，对于每个 s ∈ V，时间复杂度为 O(|V| + |E|)（第11讲）。
这也是 G 中的最短路径树，因此在使用 DFS 遍历树的同时计算距离。
耗时 O(|V| · (|V| + |E|))（比运行 |V| 次 Dijkstra 算法的时间少）。
但是如何构造一个没有负权重的 G' 呢？这真的可能吗？？
断言：如果 G 包含负权重环，则不可能。
证明：如果没有负权重，最短路径是简单的；但如果存在负权重环，则不一定。
给定一个具有负权重但没有负权重环的图 G，我们能否在不改变最短路径的前提下使边权重变为非负？
### 3. 使权重变为非负
思路一！将 G 中的最小权重的负值加到每条边上！所有权重都非负了！
失败：不保持最短路径！这会偏向于经过边数更少的路径 
思路二！给定顶点 v，将所有出边的权重加上 h，将所有入边的权重减去 h。
断言：在上述重新赋权下，最短路径保持不变。
证明：
从 v 开始的每条路径的权重变化为 +h。
在 v 结束的每条路径的权重变化为 -h。
经过 v 的路径的权重（局部）不变。
这是一个非常通用且有用的技巧，可以在保持最短路径的同时变换图！
即使对多个顶点也有效！
定义一个势函数 h：V → Z，将每个顶点 v ∈ V 映射到一个势能值 h(v)。
构造图 G'：与 G 相同，但边 (u, v) ∈ E 的权重变为 w'(u, v) = w(u, v) + h(u) - h(v)。
断言：G 中的最短路径也是 G' 中的最短路径。
证明：
路径 π = (v0, ..., vk) 在 G 中的权重为 $w(π) = Σ_{i=1}^{k} w(v_{i-1}, v_i)$。
π 在 G' 中的权重为：$Σ_{i=1}^{k} [w(v_{i-1}, v_i) + h(v_{i-1}) - h(v_i)] = w(π) + h(v0) - h(vk)$。
（h 的和是交错的，因为每个内部顶点 i 对应一个正 h(v_{i-1}) 和一个负 h(v_i)）
所有从 v0 到 vk 的路径都变化了相同的量。
因此，任何最短路径仍然是最短的。
我们能否找到一个势函数，使得 G' 中没有负边权重？
即，是否存在一个 h，使得对于每条 (u, v) ∈ E，都有 w(u, v) + h(u) - h(v) ≥ 0？
将此条件重新排列为 h(v) ≤ h(u) + w(u, v)，看起来像三角不等式！
思路！如果 h(v) = δ(s, v) 且对于某个 s，δ(s, v) 是有限的，那么这个条件将得到满足。
但图可能是不连通的，因此可能不存在这样的顶点 s... 
思路！添加一个新的顶点 s，并添加一条指向每个 v ∈ V 的权重为 0 的有向边！ 
对于所有 v ∈ V，δ(s, v) ≤ 0，因为存在一条权重为 0 的路径。
断言：如果对于任何 v ∈ V，δ(s, v) = -∞，则原图存在负权重环。
证明：
添加 s 不会引入新的环（s 没有入边）。
因此，如果重新赋权后的图存在负权重环，那么原图也存在负权重环。
或者，如果对于所有 v ∈ V，δ(s, v) 都是有限的：
根据三角不等式，对于每条 (u, v) ∈ E，有 w'(u, v) = w(u, v) + h(u) - h(v) ≥ 0！
G' 中的新权重在保持最短路径不变的同时变为非负！
### 4. Johnson 算法
构造 Gx：在 G 中添加顶点 x，并用权重为 0 的边连接到每个顶点 v ∈ V。
计算每个 v ∈ V 的 δx(x, v)（使用 Bellman-Ford 算法）。
如果对于任何 v ∈ V，有 δx(x, v) = -∞：
中止（因为 G 中存在负权重环）。
否则：
重新赋权每条边：w'(u, v) = w(u, v) + δx(x, u) - δx(x, v)，形成图 G'。
对于每个 u ∈ V：
计算 G' 中从 u 到所有 v 的最短路径距离 δ'(u, v)（使用 Dijkstra 算法）。
计算所有 v ∈ V 的 δ(u, v) = δ'(u, v) - δx(x, u) + δx(x, v)。
### 5. 正确性
已经证明了从 G 到 G' 的变换保持了最短路径。
其余部分归结为 Bellman-Ford 和 Dijkstra 算法的正确性。
这是从带符号的 APSP 问题到非负权重的 APSP 问题的规约。
### 6. 运行时间
构造 Gx 的时间：O(|V| + |E|)
Bellman-Ford 算法的时间：O(|V||E|)
构造 G' 的时间：O(|V| + |E|) 
|V| 次运行 Dijkstra 算法的时间：O(|V|·(|V| log |V| + |E|))
从 G' 中的距离计算 G 中的距离的时间：O(|V|²)
总时间：O(|V|² log |V| + |V||E|)
___
[返回目录](#目录)
___
## Lecture 15: Dynamic Programming I <a id = "l15"></a>
### 1. 如何解决算法问题
设计你自己的递归算法
用于解决任意输入的常量大小程序
需要循环或递归，通过归纳法分析
递归函数调用：图中的顶点，如果 B 调用 A，则存在从 A → B 的有向边
递归调用的依赖图必须是无环的（如果可以终止）
基于图的形状分类
|类别|图形|
| :---: | :---: |
|暴力枚举|星形|
|减治|链式|
|分治|树形|
|动态规划|有向无环图|
|贪心/增量|子图|

难点在于归纳思考以构建子问题的递推关系
如何递归地解决问题（SRT BOT 框架）
1. 子问题定义
2. 递归地关联子问题解
3. 子问题的拓扑序（⇒ 子问题 DAG）
4. 关系的基本情况
5. 通过子问题解得到原问题解
6. 时间分析
### 2. 归并排序的 SRT BOT 框架表示
对一个包含 n 个元素的数组 A 进行归并排序，在 SRT BOT 框架中可表示如下：
1. 子问题：S(i, j) = 对 A[i:j] 的元素进行排序后的数组，其中 0 ≤ i ≤ j ≤ n
2. 关系：S(i, j) = merge(S(i, m), S(m, j))，其中 m = ⌊(i + j)/2⌋
3. 拓扑序：按 j - i 递增的顺序
4. 基本情况：S(i, i + 1) = [A[i]]
5. 原问题：S(0, n)
6. 时间：T(n) = 2T(n/2) + O(n) = O(n log n)

此例子中，子问题依赖图是一个树形结构（分治算法）
### 3. 斐波那契数列
假设我们要计算第 n 个斐波那契数 $F_n$
1. 子问题：F(i) = 第 i 个斐波那契数 $F_i$，其中 i ∈ {0, 1, ..., n}
2. 关系：F(i) = F(i - 1) + F(i - 2) （斐波那契数的定义）
3. 拓扑序：按 i 递增的顺序
4. 基本情况：F(0) = 0, F(1) = 1
5. 原问题：F(n)
6. 时间：T(n) = T(n-1) + T(n-2) + O(1) > 2T(n-2)，所以 T(n) = Ω($2^{n/2}$) 呈指数级增长...
```python
def fib(n):
    if n < 2: return n  # 基本情况
    return fib(n - 1) + fib(n - 2)  # 递推关系
```
分治策略意味着递归调用树（可画出树状图）
子问题 F(k) 被计算了不止一次！（计算了 F(n-k) 次）
我们能避免这种浪费吗？
### 4. 复用子问题的解
将子问题依赖关系画成 DAG（有向无环图）
求解时，可选择：
自顶向下：在备忘录中记录子问题的解并复用（递归 + 记忆化）
自底向上：按拓扑排序顺序解决子问题（通常通过循环）
对于斐波那契数列，有 n+1 个子问题（顶点）和 < 2n 个依赖（边）
计算时间就是 O(n) 次加法
```python
# 递归解法（自顶向下）
def fib(n):
    memo = {}
    def F(i):
        if i < 2: return i  # 基本情况
        if i not in memo:  # 检查备忘录
            memo[i] = F(i-1) + F(i-2)  # 关系
        return memo[i]
    return F(n)  # 原问题
# 迭代解法（自底向上）
def fib(n):
    F = {}
    F[0], F[1] = 0, 1  # 基本情况
    for i in range(2, n+1):  # 拓扑序
        F[i] = F[i-1] + F[i-2]  # 关系
    return F[n]  # 原问题
```
一个微妙之处在于斐波那契数会增长到 Θ(n) 比特长，可能涉及 
每次加法消耗 O(⌈n/w⌉) 时间，其中 w 是字长
所以总成本为 O(n⌈n/w⌉) = O($n + n^2/w$) 时间
### 5. 动态规划
这个奇怪的名字由 Richard Bellman 创造
递归解的存在意味着问题可分解为子问题
此性质常被称为最优子结构。它是递归的性质，不仅仅是动态规划的特性。
递归算法意味着一个计算图
如果子问题的依赖关系重叠（DAG，入度 > 1），则属于动态规划
"递归但要复用" （自顶向下：记录并查找子问题的解）
"精心的暴力枚举" （自底向上：按顺序处理每个子问题）
通常用于计数/优化问题：递推关系几乎总是正确的
### 6. 如何递归地解决问题（SRT BOT）
1. 子问题定义：子问题 x ∈ X
- 用参数描述子问题的含义
- 通常是输入的子集：序列的前缀、后缀、连续子串
- 通常记录部分状态：通过增加一些辅助变量来添加子问题
2. 递归地关联子问题解：x(i) = f(x(j), ...) 对于一个或多个 j < i
3. 拓扑序：论证关系是无环的，且子问题构成 DAG
4. 基本情况：为所有（可达的）独立的子问题给出解，这些子问题中关系不适用
5. 原问题：
- 展示如何从子问题的解计算出原问题的解
- 可能需要使用父指针来恢复实际的解，而不仅仅是目标函数值
6. 时间分析:
- ∑(x ∈ X) work(x)，或者如果对所有 x ∈ X 有 work(x) = O(W)，则为 |X| · O(W)
- work(x) 衡量关系中非递归的工作量；将递归调用视为消耗 O(1) 时间
### 7. DAG 单源最短路径
回顾 DAG SSSP 问题：给定一个 DAG G 和源点 s，计算所有顶点 v ∈ V 的 δ(s, v)
1. 子问题：对所有 v ∈ V，计算 δ(s, v)
2. 关系：δ(s, v) = min{ δ(s, u) + w(u, v) | u ∈ Adj⁻(v) } ∪ {∞}
3. 拓扑序：G 的拓扑序
4. 基本情况：δ(s, s) = 0
5. 原问题：所有子问题
6. 时间：∑(v∈V) O(1 + |Adj⁻(v)|) = O(|V| + |E|)

DAG 松弛算法计算出的最小值与此动态规划相同，只是它是一步一步进行的（如果新值 < 当前最小值，则通过边松弛更新最小值），并且是从 u 和 Adj⁺(u) 的角度，而不是 v 和 Adj⁻(v) 的角度
### 8. 保龄球问题
给定 n 个瓶柱，标记为 0, 1, ..., n-1
瓶柱 i 的价值为 $v_i$
一个与瓶柱大小相似的球可以击中：
- 1 个瓶柱 i，此时获得 $v_i$ 分
- 2 个相邻的瓶柱 i 和 i+1，此时获得 $v_i · v_{i+1}$ 分

一旦一个瓶柱被击中，就不能再被击中（被移除）
问题：投掷零个或多个球以最大化总得分
### 9. 保龄球问题算法
首先看一个更熟悉的分治算法：
1. 子问题：B(i, j) = 仅从瓶柱 i, i+1, ..., j-1 开始能获得的最大得分，其中 0 ≤ i ≤ j ≤ n
2. 关系：m = ⌊(i + j)/2⌋
- 要么同时击中 m 和 m+1，要么不这样做
- $B(i, j) = max\{ v_m · v_{m+1} + B(i, m) + B(m+2, j), B(i, m+1) + B(m+1, j) \}$
3. 拓扑序：按 j - i 递增的顺序
4. 基本情况：B(i, i) = 0, B(i, i+1) = max{v_i, 0}
5. 原问题：B(0, n)
6. 时间：T(n) = 4T(n/2) + O(1) = O(n^2)

这个算法有效，但不够快，且泛化能力不强（例如，如果允许击中三个瓶柱的更大球）
动态规划算法：使用后缀
1. 子问题：B(i) = 仅从瓶柱 i, i+1, ..., n-1 开始能获得的最大得分，其中 0 ≤ i ≤ n
2. 关系：
- 对第一个瓶柱（原瓶柱 i）可能发生的情况进行局部暴力枚举：跳过瓶柱、击中一个瓶柱、击中两个瓶柱
- 归结为更小的后缀并递归，要么是 B(i+1)，要么是 B(i+2)
- $B(i) = max\{ B(i+1), v_i + B(i+1), v_i · v_{i+1} + B(i+2) \}$
3. 拓扑序：按 i 递减的顺序（对于 i = n, n-1, ..., 0）
4. 基本情况：B(n) = B(n+1) = 0
5. 原问题：B(0)
6. 时间：（假设使用了记忆化）：Θ(n) 个子问题 · 每个子问题 Θ(1) 工作量，总计 Θ(n) 时间

快速且易于泛化！
![p14](./笔记插图集/p14.png)
### 10. 保龄球问题代码
将 SRT BOT 规范转化为代码是直接且自动的
以下是上述保龄球动态规划的实现：
```python
# 递归解法（自顶向下）
def bowl(v):
    memo = {}
    def B(i):
        if i >= len(v): return 0  # 基本情况
        if i not in memo:  # 检查备忘录
            memo[i] = max(B(i+1),        # 关系：跳过瓶柱 i
                         v[i] + B(i+1),   # 或者单独击倒瓶柱 i
                         v[i] * v[i+1] + B(i+2)) # 或者同时击倒瓶柱 i 和 i+1
        return memo[i]
    return B(0)  # 原问题
# 迭代解法（自底向上）
def bowl(v):
    B = {}
    B[len(v)] = 0       # 基本情况
    B[len(v)+1] = 0     # 基本情况
    for i in reversed(range(len(v))):  # 拓扑序
        B[i] = max(B[i+1],               # 关系：跳过瓶柱 i
                   v[i] + B[i+1],        # 或者单独击倒瓶柱 i
                   v[i] * v[i+1] + B[i+2]) # 或者同时击倒瓶柱 i 和 i+1
    return B[0]  # 原问题
```
如何关联子问题解
我们遵循的一般方法来定义子问题解之间的关系：
识别一个问题：关于子问题解，如果你知道答案，就能将其简化为"更小"的子问题。
在保龄球例子中，问题是"我们如何处理前几个瓶柱？"
然后局部暴力枚举这个问题，尝试所有可能的答案，并取最优者。
在保龄球例子中，我们取最大值，因为问题要求最大化。
或者，我们可以想象正确地猜出问题的答案，并直接递归；但实际上我们会检查所有可能的猜测，并返回"最佳"的那个。
效率的关键在于问题要有少量（多项式级别）的可能答案，这样暴力枚举才不会太昂贵。
通常（但不总是），计算关系的非递归工作量等于我们尝试的答案数量。
___
[返回目录](#目录)
___
## Lecture 16: Dynamic Programming II <a id = "l16"></a>
### 1. 最长公共子序列（LCS）
给定两个字符串 A 和 B，找出 A 的一个（不一定连续）最长的子序列，该子序列同时也是 B 的子序列。
这是一个关于子序列长度的最大化问题。
1. 子问题：x(i, j) = 后缀 A[i:] 和 B[j:] 的最长公共子序列的长度，其中 0 ≤ i ≤ |A|, 0 ≤ j ≤ |B|
2. 关系
- 要么首字符匹配，要么不匹配
- 如果首字符匹配，某个最长公共子序列会使用它们
（如果没有 LCS 使用这对匹配的首字符，使用它只会改进解）
（如果一个 LCS 使用了 A[i] 的第一个字符而未使用 B[j] 的第一个字符，那么匹配 B[j] 也是最优的）
- 如果不匹配，它们不可能同时出现在一个最长公共子序列中
- 猜测 A[i] 或 B[j] 是否不在 LCS 中
- x(i, j) = { x(i+1, j+1) + 1, 如果 A[i] == B[j]；否则 max{ x(i+1, j), x(i, j+1) } }
- （画出整个矩形网格依赖关系的子集）
3. 拓扑序
- 子问题 x(i, j) 仅依赖于严格更大的 i 或 j 或两者
- 最简单的描述顺序：按 i + j 递减
- 自底向上代码的合适顺序：i 递减，然后 j 递减
4. 基本情况：x(i, |B|) = x(|A|, j) = 0（其中一个字符串为空）
5. 原问题：
- A 和 B 的最长公共子序列长度是 x(0, 0)
- 存储父指针以重构子序列
- 如果父指针同时增加了两个索引，则将该字符添加到 LCS 中
6. 时间
- 子问题数量：(|A| + 1) · (|B| + 1)
- 每个子问题工作量：O(1)
- 运行时间：O(|A| · |B|)
```python
def lcs(A, B):
    a, b = len(A), len(B)
    x = [[0] * (b + 1) for _ in range(a + 1)]
    for i in reversed(range(a)):
        for j in reversed(range(b)):
            if A[i] == B[j]:
                x[i][j] = x[i + 1][j + 1] + 1
            else:
                x[i][j] = max(x[i + 1][j], x[i][j + 1])
    return x[0][0]
```
### 2. 最长递增子序列（LIS）
给定一个字符串 A，找出 A 的一个（不一定连续）最长的、严格递增（按字典序）的子序列。
这是一个关于子序列长度的最大化问题。
尝试的解决方案：
自然的子问题是 A 的前缀或后缀，例如后缀 A[i:]
关于 A[i:] 的 LIS 的自然问题是：A[i] 在 LIS 中吗？（2 种可能答案）
但如何递归处理 A[i+1:] 并保证递增子序列呢？
修正：为子问题添加约束，以提供足够的结构来实现递增性质。
1. 子问题：x(i) = 后缀 A[i:] 中包含 A[i] 的最长递增子序列的长度，其中 0 ≤ i ≤ |A|
2. 关系
- 我们已知 A[i] 在 LIS 中（作为第一个元素）
- 下一个问题：LIS 的第二个元素是什么？
   - 可以是任何满足 j > i 且 A[j] > A[i] 的 A[j]（以保证递增）
   - 或者 A[i] 可能是 LIS 的最后一个元素
- x(i) = max{ 1 + x(j) | i < j < |A|, A[j] > A[i] } ∪ {1}
3. 拓扑序：按 i 递减
4. 基本情况：不需要单独的基本情况，因为我们考虑了 A[i] 是最后一个元素的可能性
5. 原问题：
- LIS 的第一个元素是什么？猜测！
- A 的 LIS 长度是 max{ x(i) | 0 ≤ i < |A| }
- 存储父指针以重构子序列
6. 时间
- 子问题数量：|A|
- 每个子问题工作量：O(|A|)
- 运行时间：O(|A|²)
```python
def lis(A):
    a = len(A)
    x = [1] * a
    for i in reversed(range(a)):
        for j in range(i, a):
            if A[j] > A[i]:
                x[i] = max(x[i], 1 + x[j])
    return max(x)
```
### 3. 交替硬币游戏
给定价值为 v₀, v₁, ..., $v_{n-1}$ 的 n 枚硬币序列
两个玩家（"我"和"你"）轮流行动
在每一回合，从剩余硬币中拿走最左边或最右边的一枚
我的目标是最大化我拿走的硬币总价值，我先手
第一种解法利用了这是一个零和博弈：我拿走所有你没拿的硬币。
1. 子问题
- 选择对应于游戏状态的子问题
- 对于每一段从 i 到 j 的连续硬币子序列，0 ≤ i ≤ j < n
- x(i, j) = 从价值为 $v_i$, ..., $v_j$ 的硬币开始，我能拿到的最大总价值
2. 关系
- 我必须选择硬币 i 或硬币 j（猜测！）
- 然后轮到你了，你将分别得到价值 x(i+1, j) 或 x(i, j-1)
- 为了计算我得到多少价值，从硬币总价值中减去这部分
- $x(i, j) = max\{ v_i + ( ∑{k=i+1}^{j} v_k - x(i+1, j) ), v_j + ( ∑{k=i}^{j-1} v_k - x(i, j-1) )\}$
3. 拓扑序：按 j - i 递增
4. 基本情况：$x(i, i) = v_i$
5. 原问题：$x(0, n-1)$，存储父指针以重构策略
6. 时间
- 子问题数量：Θ(n²)
- 每个子问题工作量：Θ(n) 用于计算总和
- 运行时间：Θ(n³)

第二种解法使用了子问题扩展：为接下来轮到谁移动添加子问题。
1. 子问题
- 选择对应于游戏完整状态的子问题
- 从 i 到 j 的连续硬币子序列，以及接下来轮到哪个玩家 p
- x(i, j, p) = 当玩家 p ∈ {我, 你} 从价值为 v_i, ..., v_j 的硬币开始时，我能获得的最大总价值
2. 关系
- 玩家 p 必须选择硬币 i 或硬币 j（猜测！）
- 如果 p = 我，那么我获得该硬币价值；否则，我什么也得不到
- 然后轮到另一个玩家
   - x(i, j, 我) = max{ v_i + x(i+1, j, 你), v_j + x(i, j-1, 你) }
   - x(i, j, 你) = min{ x(i+1, j, 我), x(i, j-1, 我) }
3. 拓扑序：按 j - i 递增
4. 基本情况：$x(i, i, 我) = v_i$，$x(i, i, 你) = 0$
5. 原问题：x(0, n-1, 我) 存储父指针以重构策略
6. 时间
- 子问题数量：Θ(n²)
- 每个子问题工作量：Θ(1)
- 运行时间：Θ(n²)
### 4. 子问题约束与扩展
我们现在已经看到了两个约束或扩展子问题的例子
如果你发现自己缺乏信息来检查问题所需的条件，或者缺乏可以递归处理的自然子问题，尝试子问题约束/扩展！
更多的子问题和约束为关系提供了更多可操作的信息，因此可以使动态规划更可行
通常在子问题数量与关系的分支/复杂度之间存在权衡
___
[返回目录](#目录)
___
## Lecture 17: Dynamic Programming III <a id = "l17"></a>
### 1. 单源最短路径问题再探讨
1. 子问题：
- 扩展子问题以添加信息使其无环！ （这是我们之前见过的子问题扩展的一个例子）
- $δ_k$(s, v) = 从 s 到 v 的、使用最多 k 条边的最短路径的权重，对于 v ∈ V 且 0 ≤ k ≤ |V|
2. 关系：
- 猜测从 s 到 v 的最短路径上的最后一条边 (u, v)
- $δ_k(s, v) = min\{ δ_{k-1}(s, u) + w(u, v) | (u, v) ∈ E \} ∪ \{ δ_{k-1}(s, v) \}$
3. 拓扑序：k 递增：子问题仅依赖于严格更小 k 的子问题
4. 基本情况：δ_0(s, s) = 0 且对于 v ≠ s，δ_0(s, v) = ∞（无边）
5. 原问题
- 如果存在有限的最短路径，则 δ(s, v) = δ_{|V|-1}(s, v)
- 否则某个 δ_{|V|}(s, v) < δ_{|V|-1}(s, v)，这意味着路径包含负权环
- 可以记录父指针以追踪使递推关系最小的子问题
6. 时间
- 子问题数量：|V| × (|V| + 1)
- 子问题 δ_k(s, v) 的工作量：O(in_degree(v))
- 总工作量：$∑{k=0}^{|V|} ∑{v∈V} O(in_degree(v)) = ∑_{k=0}^{|V|} O(|E|) = O(|V|·|E|)$

这只是 Bellman-Ford 算法！（只是计算的顺序略有不同）
### 2. 全对最短路径：Floyd-Warshall 算法
可以像 Bellman-Ford 那样定义子问题 $δ_k$(u, v) = 从 u 到 v 的、使用最多 k 条边的最短路径的最小权重。
这样得到的运行时间是 Bellman-Ford 的 |V| 倍，即 O(|V|²·|E|) = O(|V|⁴)
通过一个简单的动态规划（称为 Floyd-Warshall 算法）可以达到 Θ(|V|³) 的运行时间（在稠密图上与 Johnson 算法相当）。
给顶点编号，使得 V = {1, 2, ..., |V|}
1. 子问题：d(u, v, k) = 从 u 到 v 的、仅使用顶点 {1, 2, ..., k} ∪ {u, v} 的最短路径的最小权重，对于 u, v ∈ V 且 1 ≤ k ≤ |V|
2. 关系：d(u, v, k) = min{ d(u, k, k-1) + d(k, v, k-1), d(u, v, k-1) }，只有常数级分支！不再猜测前一个顶点/边。
3. 拓扑序：k 递增：关系仅依赖于更小的 k
4. 基本情况：
- d(u, u, 0) = 0
- 如果 (u, v) ∈ E，则 d(u, v, 0) = w(u, v)
- 否则 d(u, v, 0) = ∞
5. 原问题：对所有 u, v ∈ V，求 d(u, v, |V|)
6. 时间
- 子问题数量：O(|V|³)
- 每个子问题 O(1) 工作量
- 总共 O(|V|³)
- 每个子问题的依赖关系数量为常数，将运行时间中的 O(|E|) 因子降为 O(|V|)。
### 3. 算术表达式括号化
输入：算术表达式$ a₀ *₁ a₁ *₂ a₂ ... *_{n-1} a_{n-1}$
其中每个 $a_i$ 是整数，每个 $*_i ∈ {+, ×}$
输出：放置括号的位置，以最大化表达式的求值结果
允许负整数！
1. 子问题
- 最大化每个子数组就够了吗？不！ (-3) × (-3) = 9 > (-2) × (-2) = 4
- x(i, j, opt) = 通过给 $a_i *{i+1} ... *{j-1} a_{j-1}$ 加括号所能获得的最优值（opt ∈ {最小值, 最大值}）
- 对于 0 ≤ i < j ≤ n 且 opt ∈ {最小值, 最大值}
2. 关系
- 猜测最外层括号的位置 / 最后执行的操作
- $x(i, j, opt) = opt { x(i, k, opt') *_k x(k, j, opt'') | i < k < j; opt', opt'' ∈ {最小值, 最大值} }$
3. 拓扑序：j - i 递增：子问题 x(i, j, opt) 仅依赖于严格更小的 j - i
4. 基本情况：$x(i, i+1, opt) = a_i$（只有一个数，没有操作可执行！）
5. 原问题：
- x(0, n, 最大值)
- 存储父指针（两个！）以找到括号化方案（形成二叉树！）
6. 时间
- 子问题数量：少于 n·n·2 = O(n²)
- 每个子问题工作量：O(n)·2·2 = O(n)
- 运行时间：O(n³)
### 4. 钢琴指法安排
给定用右手演奏的 n 个单音符序列 $t₀, t₁, ..., t_{n-1}$（稍后将推广到多音符和多手情况）
演奏者右手有手指 1, 2, ..., F（对于大多数人，F = 5）
给定衡量从用指 f 弹奏音符 t 过渡到用指 f' 弹奏音符 t' 的难度度量 d(t, f, t', f')。
通常是各种难度惩罚的总和，例如：
1 < f < f' 且 t > t' 是不舒服的
Legato（平滑）演奏要求 t ≠ t'（否则无限惩罚）
弱指规则：尽量避免 f' ∈ {4, 5}
{f, f'} = {3, 4} 是烦人的
目标：为音符分配手指以最小化总难度
第一次尝试：
- 子问题：x(i) = 演奏音符 $t_i, t_{i+1}, ..., t_{n-1}$ 的最小总难度。
- 关系：猜测第一个手指：为 $t_i$ 分配 f。
$x(i) = min{ x(i+1) + d(t_i, f, t_{i+1}, ?) | 1 ≤ f ≤ F }$

没有足够的信息来填充 ?。需要知道 x(i+1) 的起始手指是哪个。
但不同的起始手指可能同时影响 x(i+1) 和 $d(t_i, f, t_{i+1}, ?)$。
需要一个从起始手指到 x(i+1) 最优解的映射表。
即，需要用起始条件来扩展子问题。
解决方案：
1. 子问题：x(i, f) = 从用指 f 在音符 $t_i$ 上开始，演奏音符 $t_i, t_{i+1}, ..., t_{n-1}$ 的最小总难度。对于 0 ≤ i < n 且 1 ≤ f ≤ F
2. 关系
- 猜测下一个手指：为 t_{i+1} 分配 f'
- $x(i, f) = min{ x(i+1, f') + d(t_i, f, t_{i+1}, f') | 1 ≤ f' ≤ F }$
3. 拓扑序：i 递减（f 顺序任意）
4. 基本情况：x(n-1, f) = 0（没有过渡）
5. 原问题：min{ x(0, f) | 1 ≤ f ≤ F }
6. 时间
- Θ(n·F) 个子问题
- 每个子问题 Θ(F) 工作量
- Θ(n·F²)

与不同音符的数量无关！
### 5. 吉他指法安排
最多有 S = 弦的数量种方式来弹奏同一个音符
将“手指”重新定义为元组（弹奏音符的手指，弹奏音符的弦）
在整个算法中，F 被替换为 F·S
因此运行时间为 Θ(n·F²·S²)
### 6. 同时弹奏多个音符
现在假设 $t_i$ 是时间 i 要弹奏的一组音符
给定一个更大的过渡难度函数 d(t, f, t', f')
目标：指法安排 $f_i: t_i → {1, 2, ..., F}$，指定如何为每个音符安排指法（包括吉他的哪根弦），以最小化 $∑_{i=1}^{n-1} d(t{i-1}, f_{i-1}, t_i, f_i)$
对于每个指法安排 $f_i$，最多有 $T^F$ 种选择，其中 $T = max_i |t_i|$
对于普通钢琴，T ≤ F = 10（但也有例外）
对于吉他，T ≤ S
Θ(n·$T^F$) 个子问题
每个子问题 Θ($T^F$) 工作量
Θ($n·T^{2F}$) 时间
对于 T, F ≤ 10，为 Θ(n) 时间
___
[返回目录](#目录)
___
## Lecture 18: Dynamic Programming IV <a id = "l18"></a>
### 1. 钢条切割问题
给定一段长度为 L 的钢条，以及所有长度 ∈ {1, 2, ..., L} 的钢条的价值 v(`)。
目标：切割钢条，使得切割后各段钢条的总价值最大。
示例：L = 7, v = [0, 1, 10, 13, 18, 20, 31, 32]
长度 ` = 0 1 2 3 4 5 6 7
也许贪心地取单位长度价值最高的？不行！arg max_v[]/` = 6，而分割方案 [6, 1] 得到 32，这不是最优的！
最优解：v[2] + v[2] + v[3] = 10 + 10 + 13 = 33
这是一个关于分割价值的最大化问题。
1. 子问题：x(): 长度为 的钢条通过切割能获得的最大价值，对于 ` ∈ {0, 1, ..., L}
2. 关系
- 第一段的长度是 p（猜测！）
- x() = max{ v(p) + x( - p) | p ∈ {1, ..., `} }
3. 拓扑序：递增：子问题 x() 仅依赖于严格更小的 `，因此是无环的。
4. 基本情况：x(0) = 0（长度为 0 的钢条没有价值！）
5. 原问题
- 长度为 L 的钢条通过切割能获得的最大价值是 x(L)
- 存储选择以重构切割方案
- 如果当前钢条长度为 ，最优选择是'，则剩余段长度为 p = -'
- （这是子问题 DAG 中的最大权重路径！）
6. 时间：
- 子问题数量：L + 1
- 每个子问题工作量：O(`) = O(L)
- 运行时间：O(L²)

这是多项式时间吗？
（强）多项式时间意味着运行时间以输入规模（按字度量）的常数次多项式为上界。
在钢条切割问题中，输入规模是 L + 1 个字（一个整数 L 和 v 中的 L 个整数）。
O(L²) 是 L + 1 的常数次多项式，所以 是：（强）多项式时间。
```python
# 递归版本（带备忘录）
x = {}
def cut_rod(l, v):
    if l < 1: return 0  # 基本情况
    if l not in x:       # 检查备忘录
        for piece in range(1, l + 1):            # 尝试每个切段长度
            x_ = v[piece] + cut_rod(l - piece, v)  # 递推关系
            if (l not in x) or (x[l] < x_):        # 更新备忘录
                x[l] = x_
    return x[l]

# 迭代版本（自底向上）
def cut_rod(L, v):
    x = [0] * (L + 1)               # 基本情况
    for l in range(L + 1):          # 拓扑序
        for piece in range(1, l + 1):   # 尝试每个切段长度
            x_ = v[piece] + x[l - piece] # 递推关系
            if x[l] < x_:                # 更新
                x[l] = x_
    return x[L]

# 带父指针的迭代版本
def cut_rod_pieces(L, v):
    x = [0] * (L + 1)               # 基本情况
    parent = [None] * (L + 1)       # 父指针
    for l in range(1, L + 1):       # 拓扑序
        for piece in range(1, l + 1):   # 尝试每个切段长度
            x_ = v[piece] + x[l - piece] # 递推关系
            if x[l] < x_:                # 更新备忘录
                x[l] = x_
                parent[l] = l - piece    # 更新父指针
    l, pieces = L, []
    while parent[l] is not None:    # 回溯父指针重构方案
        piece = l - parent[l]
        pieces.append(piece)
        l = parent[l]
    return pieces
```
### 2. 子集和问题
输入：一个由 n 个正整数组成的序列 A = {a₀, a₁, ..., $a_{n-1}$}
输出：是否存在 A 的一个子集，其元素之和恰好等于 T？（即，∃ A' ⊆ A 使得 $∑_{a∈A'} a = T$？）
示例：A = (1, 3, 4, 12, 19, 21, 22)，T = 47，允许 A' = {3, 4, 19, 21}
这是优化问题吗？是判定问题！答案是 YES 或 NO，TRUE 或 FALSE。
在示例中，答案是 YES。然而，对于某些 T，答案是 NO，例如 2, 6, 9, 10, 11,...
1. 子问题：x(i, t) = A[i:] 的任何子集的和是否等于 t？对于 i ∈ {0, 1, ..., n}，t ∈ {0, 1, ..., T}
2. 关系
- 想法：第一个元素 $a_i$ 在有效的子集 A' 中吗？（猜测！）
- 如果 是，则尝试用剩余元素凑出 $t - a_i ≥ 0$
- 如果 否，则尝试用剩余元素凑出 t
- x(i, t) = x(i+1, t - A[i]) （如果 t ≥ A[i]） OR x(i+1, t) （总是成立）
3. 拓扑序：子问题 x(i, t) 仅依赖于严格更大的 i，所以是无环的。按 i 递减的顺序求解。
4. 基本情况
- 对于 i ∈ {0, ..., n}，x(i, 0) = YES（空间恰好填满！）
- 对于 t ∈ {1, ..., T}，x(n, t) = NO（没有更多物品可用于填充）
5. 原问题
- 原问题由 x(0, T) 给出。
示例：A = (3, 4, 3, 1)，T = 6，解：A' = (3, 3)
   - 自底向上：求解所有子问题（示例有 35 个）
   - 自顶向下：只求解可达的子问题（示例只有 14 个！）
6. 时间
- 子问题数量：O(nT)
- 每个子问题 O(1) 工作量
- O(nT) 时间

![p15](./笔记插图集/p15.png)
这是多项式时间吗？
输入规模是 n + 1：一个整数 T 和 A 中的 n 个整数。
O(nT) 是否以 n + 1 的多项式为上界？不，不一定。
在 w 位字 RAM 模型中，T ≤ 2^w 且 w ≥ lg(n+1)，但我们没有 w 的上界。
例如，w = n 并非不合理，但此时的运行时间是 O($n·2^n$)，这是指数级的。
### 3. 伪多项式时间
一个算法具有伪多项式时间：运行时间以输入规模和输入整数值的常数次多项式为上界。
这类算法在整数大小以输入规模的多项式（即 $n^O(1)$）为界的情况下是多项式时间的（与基数排序在 O(n) 时间内运行的情况相同）。
计数排序 O(n + u)，基数排序 O(n $log_n$ u)，直接访问数组构建 O(n + u)，以及斐波那契 O(n) 都是我们已经见过的伪多项式时间算法。
基数排序实际上是弱多项式时间（介于强多项式和伪多项式之间的概念）：运行时间以按比特度量的输入规模（即输入整数的对数）的常数次多项式为上界。
与钢条切割问题对比，后者是多项式时间的：
它对 L 有伪多项式依赖。
但幸运的是，它也有 ≥ L 个输入整数。
如果只给定可销售钢条长度的子集（背包问题，它推广了钢条切割和子集和——见习题课），那么算法将只是伪多项式时间的。
### 4. 复杂性
当整数不是多项式有界时，子集和问题能否在多项式时间内解决？
如果 P ≠ NP，那么不能。
### 5. 动态规划的主要特征
- 子问题类型：
   - 前缀/后缀：保龄球问题、LCS、LIS、Floyd-Warshall、钢条切割（巧合地，本质上是整数子问题）、子集和问题。
   - 子串：交替硬币游戏、算术表达式括号化。
   - 多序列：LCS。
   - 整数：斐波那契、钢条切割、子集和问题（伪多项式时间：斐波那契、子集和问题）。
   - 顶点：DAG 最短路径、Bellman-Ford、Floyd-Warshall。
- 子问题约束/扩展：
   - 非扩展性约束：LIS（包含第一个元素）。
   - 2 倍扩展：交替硬币游戏（谁先走？）、算术表达式括号化（最小/最大值）。
   - Θ(1) 倍扩展：钢琴指法安排（第一个手指分配）。
   - Θ(n) 倍扩展：Bellman-Ford（边数）。
- 关系（递推式）：
   - 分支数 = 每个子问题中依赖的子问题数量。
   - Θ(1) 分支：斐波那契、保龄球问题、LCS、交替硬币游戏、Floyd-Warshall、子集和问题。
   - Θ(度数) 分支（运行时间中 |E| 的来源）：DAG 最短路径、Bellman-Ford。
   - Θ(n) 分支：LIS、算术表达式括号化、钢条切割。
   - 组合多个解（不是子问题 DAG 中的路径）：斐波那契、Floyd-Warshall、算术表达式括号化。
- 原问题求解方式：
   - 组合多个子问题：DAG 最短路径、Bellman-Ford、Floyd-Warshall、LIS、钢琴指法安排。
___
[返回目录](#目录)
___
## Lecture 19: Complexity <a id = "l19"></a>
### 1. 判定问题
判定问题：将输入映射为 YES (1) 或 NO (0)
| 判定问题 | 描述 |
| :--- | :--- |
| s-t 最短路径 | 给定图 G 中是否存在一条从 s 到 t 且权重不超过 d 的路径？ |
| 负权环 | 给定图 G 中是否包含一个负权重的环？ |
| 最长简单路径 | 给定图 G 中是否存在一条权重至少为 d 的简单路径？ |
| 子集和 | 给定整数集 A 中是否存在一个子集，其和为 S？ |
| 俄罗斯方块 | 在给定的棋盘上，给定一个方块序列，能否存活？ |
| 国际象棋 | 在给定棋盘上，一名玩家能否迫使自己获胜？ |
| 停机问题 | 给定的计算机程序对于给定的输入是否会终止？ |

算法/程序：解决一个问题的常量长度代码（在字长为 Ω(log n) 位的字 RAM 上运行），即它为每个输入产生正确输出，且代码长度与实例规模无关。
如果存在一个程序能在有限时间内解决问题，则该问题是可判定的。
### 2. 可判定性
程序是有限的（常量）比特串，即一个非负整数 ∈ N。
问题是函数 p: N → {0, 1}，即无限的比特串。
（程序数量 |N|，可数无穷） < （问题数量 |R|，不可数无穷）
这证明了大多数判定问题不能被任何程序解决（不可判定）。
例如，停机问题是不可判定的
幸运的是，我们想到的大多数问题都具有算法结构，并且是可判定的。
### 3. 可判定的判定问题
R: 可在有限时间内判定的问题（'R'来源于递归语言）。
EXP: 可在指数时间 \( 2^{n^{O(1)}} \) 内判定的问题（我们想到的大多数问题都在这里）。
P: 可在多项式时间 \( n^{O(1)} \) 内判定的问题（高效算法，本课程的重点）。
这些集合是不同的，即 \( P \subseteq EXP \subseteq R \)
例如，国际象棋问题在 \( EXP \setminus P \) 中。
### 4. 非确定性多项式时间（NP）
P 是这样一类判定问题的集合：存在一个算法 A，对于每个规模为 n 的输入 I，A 在 I 上以多项式时间运行并正确求解 I。
NP 是这样一类判定问题的集合：存在一个验证算法 V，它以问题的输入 I 和一个长度为 I 规模的多项式的证书比特串作为输入，满足：
V 总是在 I 的规模的多项式时间内运行；
如果 I 是一个 YES 输入，则存在某个证书 c，使得 V 在输入 (I, c) 上输出 YES；
如果 I 是一个 NO 输入，则无论我们选择什么证书 c，V 在输入 (I, c) 上总是输出 NO。
你可以将证书视为 I 是 YES 输入的证明。如果 I 实际上是 NO 输入，那么任何证明都不应该有效。
| 问题 | 证书 | 验证器 |
| :--- | :--- | :--- |
| s-t 最短路径 | 从 s 到 t 的一条路径 P | 计算 P 上各边的权重和并检查是否 ≤ d |
| 负权环 | 一个环 C | 计算 C 上各边的权重和并检查是否 < 0 |
| 最长简单路径 | 一条路径 P | 检查 P 是否是一条权重 ≥ d 的简单路径 |
| 子集和 | 一个物品子集 A' | 检查 A' ⊆ A 的和是否为 S |
| 俄罗斯方块 | 一连串移动操作序列 | 检查这些移动操作是否能存活 |

P ⊆ NP：验证器 V 只需忽略任何证书来求解实例。
NP ⊆ EXP：尝试所有可能的证书！最多有\( 2^{n^{O(1)}} \)个，在所有证书上运行验证器 V。
开放问题：P = NP 吗？NP = EXP 吗？
大多数人认为 P ⫋ NP (⫋ EXP)，即生成解比验证解更困难。
为什么我们关心这个？如果可以证明一个问题是 NP 中最难的问题，那么如果 P ≠ NP，该问题就不能在多项式时间内解决。
我们如何关联问题的难度？归约！
### 5. 归约
假设你想解决问题 A。
一种解决方法是把 A 转换成你知道如何解决的问题 B。
使用 B 的算法来求解，并用它来计算 A 的解。
这被称为从问题 A 到问题 B 的归约（A → B）。
因为 B 可以用来解决 A，所以 B 至少和 A 一样难（A ≤ B）。
通用的算法策略：归约到一个你知道如何解决的问题。
| 问题 A | 转换方式 | 问题 B |
| :--- | :--- | :--- |
| 无权最短路径 | 赋予等权重 | 有权最短路径 |
| 整数权重最短路径 | 细分边 | 无权最短路径 |
| 最长路径 | 权重取负值 | 最短路径 |

如果 NP 中的每个问题都可以多项式归约到问题 A，则问题 A 是 NP-难的。
即，A 至少和 NP 中的每个问题一样难（对于任意 X ∈ NP，有 X ≤ A）。
NP-完全 = NP ∩ NP-难。
所有 NP-完全问题都是等价的，即可以互相归约。
第一个 NP-完全问题？每个判定问题都可以归约为满足一个逻辑电路，这个问题被称为"电路可满足性"。
最长简单路径和俄罗斯方块是 NP-完全的，因此如果存在任何问题属于 NP \ P，那么这些问题就是。
国际象棋是 EXP-完全的：在 EXP 中，并且可以归约自 EXP 中的每个问题（所以它 ∉ P）。
### 6. NP-完全问题的例子
子集和问题（"弱 NP-完全"，这使得存在伪多项式时间算法，但除非 P = NP，否则不存在多项式时间算法）。
3-划分：给定 n 个整数，能否将它们分成和相等的三元组？（"强 NP-完全"：除非 P = NP，否则不存在伪多项式时间算法）。
矩形装箱：给定 n 个矩形和一个目标矩形，其面积等于这 n 个矩形的面积之和，能否无重叠地装入？
从 3-划分到矩形装箱的归约：将整数 a_i 转换为 1 × a_i 的矩形；设置目标矩形为 (n/3) × (∑_i a_i) /3。
拼图：给定 n 个可能具有模糊凹凸的拼图片，能否将它们拼合在一起？
从矩形装箱到拼图的归约：使用唯一匹配的凹凸来强制构建矩形和矩形边界；对所有其他边界使用一种模糊的凹凸。
n 个字符串的最长公共子序列。
图中的最长简单路径。
旅行商问题：访问给定图中所有顶点的最短路径（或判定版本：最小权重是否 ≤ d）。
3D 障碍物环境中的最短路径。
给定图的 3-着色（但 2-着色 ∈ P）。
给定图中的最大团。
可满足性：给定一个布尔公式（由 AND, OR, NOT 构成），它是否可能为真？例如，x AND NOT x 是一个 NO 输入。
扫雷、数独和大多数谜题。
超级马里奥兄弟、塞尔达传说、宝可梦和大多数电子游戏都是 NP-难的（许多甚至更难）。
___
[返回目录](#目录)
___
## Lecture 20: Course Review <a id = "l20"></a>
### 1. 目标
解决困难的计算问题（输入规模非常量）。
论证一个算法的正确性（归纳法、递归）。
论证一个算法是“好”的（渐进分析、计算模型）。
### 2. 是否总是存在“好”的算法？
大多数问题无法高效求解，但我们考虑的很多问题是可以的！
多项式时间意味着运行时间是输入规模的多项式函数。
伪多项式时间意味着运行时间是输入规模以及输入中数字大小的多项式函数。
NP：非确定性多项式时间，指可在多项式时间内验证证书的问题集合。
NP-难：指这样一类问题，可以在多项式时间内用来解决 NP 中的任何问题。
NP-完全：NP-难与 NP 的交集。
### 3. 如何解决一个算法问题？
将其归约为一个你知道如何解决的问题
1. 搜索/排序（问题 1）
   - 搜索：外部（序列）和内部（集合）数据结构。
   - 排序：比较模型、稳定性、原地排序。
2. 图（问题 2）
   - 可达性、连通分量、环检测、拓扑排序。
   - 单源/全对最短路径。
3. 设计一个新的递归算法
   - 暴力枚举
   - 分治
   - 动态规划
   - 贪心/增量
___
[返回目录](#目录)

___

