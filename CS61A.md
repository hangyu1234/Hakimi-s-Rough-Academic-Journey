# UCB CS61A：Structure and Interpretation of Computer Programs
本部编号 2026-3-B
___
## 目录
[Chapter 1: Building Abstractions with Functions](#chapter1)
[Chapter 2: Building Abstractions with Data](#chapter2)
[Chapter 3: Interpreting Computer Programs](#chapter3)
[Chapter 4: Data Processing](#chapter4)
___
## Chapter 1: Building Abstractions with Functions<a id = "chapter1"></a>
### 1.1 Getting Started
#### 1. 下载python
通过访问Python下载页面获取Python 3，选择版本号以3开头的安装包
#### 2. 交互式会话
要启动交互式会话，请运行Python 3应用程序。在终端提示符后输入python3（Mac/Unix/Linux系统），或在Windows系统中直接打开Python 3应用程序。
若看到>>>提示符，则表明您已成功开启交互式会话。
在交互式Python会话中，您可以在提示符>>>后输入Python代码。Python解释器将读取并执行您输入的内容，完成各项指令。
每个会话都会保存您的输入历史记录。按`<Control>-P`（上一条）和`<Control>-N`（下一条）可查看历史命令。按`<Control>-D`将退出会话（此时历史记录会被清除）。在某些系统中，上下方向键也可用于切换历史命令。
#### 3. 语句与表达式
Python代码由表达式和语句构成
广义而言，计算机程序包含两类指令：
1. 计算某个值
2. 执行某个动作

语句通常描述动作，当Python解释器执行语句时即实施对应操作
表达式则通常描述计算过程，当Python对表达式求值时即计算其数值
- 赋值语句：将名称与等号后的表达式值相关联
- 函数：函数封装了操作数据的逻辑
- 对象：对象通过将数据与操作数据的逻辑无缝捆绑，以有效管理两者的复杂性
- 解释器：对复合表达式求值需要一个按可预测方式解释代码的精确过程，实现这一过程、用于求值复合表达式的程序称为解释器

所有这些核心概念紧密相连：函数即对象，对象即函数，而解释器则是二者的实例化体现
#### 4. 调试
学会解读错误并诊断意外问题的根源，这一过程称为调试。调试的核心原则包括：
1. 渐进测试：每个结构良好的程序都由可独立测试的小型模块化组件构成。尽可能及时测试每一段代码，以便及早发现问题，并逐步建立对各组件的信心。
2. 隔离错误：语句输出的错误通常可追溯到特定的模块化组件。诊断问题时，先尽可能将错误定位到最精简的代码片段，再尝试修正。
3. 检查预设假设：解释器会严格按指令执行——不多也不少。当代码行为与程序员所认为（或假设）的行为不符时，其输出就会显得“意外”。明确自己的假设，然后将调试重点放在验证这些假设是否实际成立上。
4. 求助他人：你并不孤单！如果不理解错误信息，可以询问朋友、导师，或借助搜索引擎。如果已定位错误但不知如何修正，不妨请他人帮忙查看。许多宝贵的编程知识正是在团队协作解决问题的过程中得以分享与传承。
### 1.2 Elements of Programming
在描述一门语言时，我们应特别关注其组合简单思想以构建复杂思想的机制。所有强大的语言都包含以下三种核心机制：
- 基本表达式与语句：构成语言基础模块的最简元素；
- 组合方法：通过特定规则将简单元素组合为复合元素；
- 抽象方法：为复合元素命名并将其作为独立单元进行操作。

编程领域中我们主要处理两类元素：函数与数据（后续我们将发现二者本质相通）。粗略而言，数据是待处理的信息原料，而函数规定了处理数据的规则准则。因此，任何强大的编程语言都应当具备描述基础数据与基础函数的能力，同时拥有组合与抽象函数及数据的方法体系。
#### 1. 基本表达式与复合表达式
数字是一种典型的基本表达式。
代表数字的表达式可以通过数学运算符组合成复合表达式，解释器将对其进行求值
这些数学表达式采用中缀表示法——运算符（如+、-、*、/）位于操作数（数字）之间
#### 2. 调用表达式
调用表达式是最重要的复合表达式类型，它将函数应用于若干参数
函数本质上是一种从输入参数到输出值的映射关系
调用表达式包含多个子表达式：运算符是括号前的表达式，括号内则是用逗号分隔的操作数表达式列表
运算符指明具体要调用的函数
调用表达式中参数的顺序至关重要
与中缀表示法相比，函数表示法具有三大显著优势：
1. 函数可以接受任意数量的参数：
2. 函数表示法能够直接扩展到嵌套表达式，其中的元素本身也可以是复合表达式。在嵌套调用表达式中，与复合中缀表达式不同，嵌套结构完全通过括号显式呈现
3. 数学符号形式多样
#### 3. 导入库函数
Python定义了非常丰富的函数集合，包括前文提及的运算符函数，但默认情况下并不会直接提供所有函数名称。相反，它将已知的函数及其他功能组件组织成模块，这些模块共同构成了Python标准库。要使用这些组件，需要通过导入语句引入。
导入语句需要指定模块名称，然后列出要从该模块导入的具名属性。函数一旦被导入，就可以被多次调用。
Python 3 标准库文档列出了每个模块定义的函数
#### 4. 名称和环境
编程语言的关键特性之一在于它提供了通过名称引用计算对象的机制。当一个值被赋予名称时，我们称该名称绑定到了这个值。
在Python中，我们可以使用赋值语句建立新的绑定。赋值语句包含：`=`，左边的名称，右边的值
名称也可以通过导入语句进行绑定
`=`符号在Python（及许多其他语言）中称为赋值运算符。赋值是我们实现抽象的最基本手段，因为它允许我们使用简短的名称来指代复合操作的结果
将名称绑定到值并后续通过名称检索这些值的可能性，意味着解释器必须维护某种记忆机制来跟踪名称、值及其绑定关系，这种记忆机制称为环境。
名称也可以绑定到函数，与数字不同，函数难以用文本直接呈现，因此当Python被要求描述函数时，它会打印一个标识性描述，我们可以使用赋值语句为现有函数赋予新名称
连续的赋值语句可以将名称重新绑定到新值
在Python中，名称常被称为变量名或变量，因为在程序执行过程中它们可以被绑定到不同的值。当一个名称通过赋值绑定到新值时，它就不再绑定到任何先前的值。我们甚至可以将内置名称绑定到新值
执行赋值语句时，Python会先计算`=`右边的表达式，再更改左边名称的绑定。因此，可以在右侧表达式中引用某个名称，即使该名称正是要被赋值语句绑定的目标
我们还可以在单条语句中为多个名称赋值多个值，`=`左侧的名称和右侧的表达式用逗号分隔，更改一个名称的值不会影响其他名称
在多重赋值中，`=`右侧的所有表达式都会在左侧任何名称绑定到这些值之前被计算。基于这一规则，交换两个名称的绑定值可以在单条语句中完成
#### 5. 表达式求值
1. 数字字面量的值即为它所代表的数值；
2. 名称的值等于当前环境中与该名称关联的值。
3. 要计算一个调用表达式，Python 将执行以下步骤：
   1. 求运算符子表达式和操作数子表达式的值；
   2. 将运算符子表达式的值（即函数）应用到操作数子表达式的值（即参数）上。

注意环境在确定表达式中符号含义时的重要作用
环境提供了求值发生的上下文，这对我们理解程序执行起着关键作用。
一般而言，语句不是被求值，而是被执行；它们并不产生值，而是引发某些改变。每种类型的表达式或语句都有其各自的求值或执行过程。
> 注：当我们说“数字字面量求值为一个数字”时，实际上是指 Python 解释器将数字字面量计算为数字。正是解释器赋予了编程语言意义。鉴于解释器是一个行为始终保持一致的固定程序，我们可以说在 Python 程序的上下文中，数字字面量（和表达式）本身会求值为相应的值。
#### 6. 纯函数与非纯函数
纯函数：函数接受若干输入（参数）并返回输出（应用函数得到的结果）。除了返回值之外，应用它们不会产生任何其他影响。此外，使用相同参数两次调用纯函数，它必须始终返回相同的值。
非纯函数：除了返回值之外，应用非纯函数还可能产生副作用，这些副作用会改变解释器或计算机的状态。
纯函数受限于它们不能具有副作用，也不能随时间改变行为。施加这些限制带来了显著的好处：
1. 纯函数可以更可靠地组合成复合调用表达式。
2. 纯函数通常更容易测试。
3. 纯函数对于编写并发程序至关重要，在并发程序中，多个调用表达式可能需要同时求值。
### 1.3 Defining New Functions
我们已经识别出 Python 中每个强大编程语言都必须具备的一些基本要素：
1. 数字和算术运算是内置的原始数据值和函数；
2. 嵌套函数应用提供了组合运算的手段；
3. 将名称绑定到值提供了有限的抽象方式。

函数定义——这是一种强大得多的抽象技术，通过它，一个名称可以绑定到复合运算，之后这个复合运算便能作为一个单元被引用。
如何定义函数。函数定义由一个 def 语句组成，该语句指明一个`<name>`和一个由逗号分隔的命名`<formal parameters>`列表，然后是一个`return`语句（称为函数体），用于指定函数的 `<return expression>`，这是一个在函数每次被调用时进行求值的表达式：
```python
def <name>(<formal parameters>):
    return <return expression>
```
第二行必须缩进——大多数程序员使用 4 个空格进行缩进。返回表达式不会立即求值；它作为新定义函数的一部分被存储，只有在函数最终被调用时才会求值。
定义了函数后，我们可以通过调用表达式来应用它
用户定义的函数与内置函数的使用方式完全相同，def 语句和赋值语句都会将名称绑定到值，并且任何现有的绑定都会丢失
#### 1. 绑定过程的环境
计算表达式时所处的环境由一系列称为帧的单元组成（通常描绘为方框）。每个帧包含一组绑定，每个绑定将一个名称与其对应的值关联起来。
存在一个全局帧。赋值语句和导入语句会向当前环境的第一帧添加条目。
函数名称会出现两次：一次在帧中，另一次作为函数本身的一部分。出现在函数中的名称称为固有名称，帧中的名称是绑定名称。两者之间存在区别：不同的名称可能引用同一个函数，但函数本身只有一个固有名称。在求值时使用的是帧中绑定到函数的名称，而函数的固有名称在求值过程中不起作用
函数签名：函数在允许接收的参数数量上有所不同。为了记录这些要求，我们绘制函数时会显示函数名及其形参。
#### 2. 调用过程的环境
为了求值一个运算符指向用户自定义函数的调用表达式，Python 解释器遵循一个计算过程。与任何调用表达式一样，解释器首先求值运算符和操作数表达式，然后将命名的函数应用于得到的参数。
应用一个用户自定义函数会引入第二个局部帧，该帧仅对该函数可访问。将用户自定义函数应用于某些参数的步骤如下：
1. 将实参绑定到新局部帧中函数的形参名称上；
2. 在以该帧起始的环境下执行函数体。

函数体求值所在的环境由两个帧组成：首先是包含形参绑定的局部帧，然后是包含其他所有内容的全局帧。每次函数应用的实例都有其独立的局部帧。
环境中的帧顺序会影响在表达式中查找名称时返回的值。名称求值规则：名称会求值为当前环境中最早找到该名称的帧所绑定的值。
#### 3. 作用域
关于函数实现的一个细节——即函数形参的命名选择——不应影响函数的行为
这一原则——函数的意义应独立于其作者选择的参数名称——对编程语言有着重要的影响。最直接的推论是：函数的参数名称必须保持在其函数体内部局部有效。
我们说局部名称的作用域仅限于定义它的用户自定义函数的函数体内部。当一个名称不再可访问时，它就超出了作用域。这种作用域行为是环境工作方式的自然结果。
#### 4. 函数命名规则
1. 函数名使用小写字母，单词之间用下划线分隔，鼓励使用描述性名称。
2. 函数名通常唤起解释器对参数执行的操作或结果值的名称
3. 参数名使用小写字母，单词之间用下划线分隔，优先选择单字名称。
4. 参数名应体现参数在函数中的作用，而不仅仅是允许的参数类型。
5. 当参数作用明显时，单字母参数名是可以接受的，但应避免使用“l”（小写 L）、“O”（大写 O）或“I”（大写 I），以免与数字混淆。
#### 5. 函数式抽象
函数定义应当能够隐藏细节。函数的使用者可能并非自己编写该函数，而是从其他程序员那里获得一个“黑箱”。程序员无需了解函数的具体实现即可使用它。Python 标准库就具备这一特性：许多开发者使用其中定义的函数，但很少有人会去检查它们的实现。
要掌握函数式抽象的使用，思考其三个核心属性通常会很有帮助：
1. 定义域：函数能够接受的参数集合；
2. 值域：函数能够返回的值集合；
3. 意图：函数在输入和输出之间计算的关系（以及可能产生的任何副作用）。

这些属性并不规定意图如何实现；该细节已被抽象掉
### 1.4 Designing Functions
什么构成了一个好的函数：
- 每个函数应当只承担一项职责
- “不要自我重复”是软件工程的核心原则
- 函数应具备一般化的定义
#### 1. 文档字符串和注释
函数定义通常会包含描述函数的文档，称为文档字符串，它必须与函数体保持相同的缩进。
文档字符串习惯上使用三引号包裹。第一行用一行文字描述函数的功能，随后的行可以描述参数并阐明函数的行为
在编写 Python 程序时，除了最简单的函数外，都应为函数添加文档字符串。
注释：Python 中的注释可以附加在行尾，以 # 符号开头。这些注释会被解释器忽略，它们的存在仅仅是为了方便人类阅读。
#### 2. 默认参数
在 Python 中，我们可以为函数的参数提供默认值。当调用该函数时，带有默认值的参数是可选参数。如果调用时未提供这些参数，则将默认值绑定到对应的形参名称上。
默认参数值以赋值运算符的方式提供
函数体中使用的大多数数据值应表示为具名参数的默认值，这样便于查看，并且可以由函数调用者更改。某些永不变化的值可以绑定在函数体内部或全局帧中。
### 1.5 Control
#### 1. 语句
语句与我们迄今为止研究的表达式有本质区别。语句不具备"值"的概念。执行控制语句并非为了计算某个结果，而是决定解释器接下来应该执行什么操作。
我们已经接触过三种语句：赋值语句、def语句和return语句。这些Python代码行本身并非表达式，尽管它们都包含表达式作为组成部分。
语句不是被"求值"，而是被"执行"。每条语句都描述了解释器状态的某种改变，执行语句就是应用这种改变
表达式也可以作为语句执行，这时它们会被求值，但其值会被丢弃。执行纯函数不会产生副作用，但执行非纯函数可能因为函数调用而产生影响。
在最高层面上，Python解释器的工作是执行由语句组成的程序。然而，计算中大量有趣的工作来自于对表达式的求值。语句控制着程序中不同表达式之间的关系，并决定如何处理它们的结果。
#### 2. 复合语句
总的来说，Python代码由一系列语句构成。简单语句是单行且不以冒号结尾的语句。复合语句之所以被称为复合，是因为它由其他语句（简单语句和复合语句）组成。复合语句通常跨越多行，起始于以冒号结尾的单行头部，该头部标识了语句的类型。头部与其下方缩进的语句集合共同构成一个子句。复合语句由一个或多个子句组成：
```python
<header>:
    <statement>
    <statement>
    ...
<separating header>:
    <statement>
    <statement>
    ...
...
```
每种头部的专用求值规则决定了其代码块中的语句何时以及是否被执行。我们说头部控制着其代码块。
要执行一个语句序列，首先执行第一条语句。如果该语句没有重定向控制流，则继续执行剩余的语句序列（如果还有语句的话）。语句按顺序执行，但由于控制流可能被重定向，后面的语句可能永远不会被执行到。
> 注：缩进代码块时，所有行必须以相同的方式和相同的缩进量进行缩进（使用空格而非制表符）。任何缩进不一致都会导致错误。
#### 3. 条件语句
Python中的条件语句由一系列头部和代码块组成：一个必需的if子句，可选的一系列elif子句，以及最后可选的else子句：
```python
if <expression>:
    <suite>
elif <expression>:
    <suite>
else:
    <suite>
```
执行条件语句时，按顺序考虑每个子句。执行条件子句的计算过程如下：
1. 求值头部表达式
2. 如果为真值，执行代码块，然后跳过条件语句中所有后续子句
3. 如果到达else子句（只有在所有if和elif表达式求值为假值时才会发生），则执行其代码块
#### 4. 布尔值和布尔表达式
条件块头部语句内的表达式被称为处于布尔上下文中：它们的真值对控制流很重要，但它们的值不会被赋值或返回
Python包含几个假值，包括0、None和布尔值False。所有其他数字都是真值。Python中每种内置数据类型都有真值和假值。
Python有两个布尔值True和False。内置的比较操作>、<、>=、<=、==、!=返回这些值。
Python还内置了三个基本逻辑运算符：
```python
>>> True and False
False
>>> True or False
True
>>> not False
True
```
逻辑表达式有相应的求值过程。这些过程利用了逻辑表达式的真值有时可以在不求值所有子表达式的情况下确定的特点，这种特性称为短路求值。
求值表达式<左> and <右>：
1. 求值子表达式<左>
2. 如果结果是假值v，则表达式求值为v
3. 否则，表达式求值为子表达式<右>的值

求值表达式<左> or <右>：
1. 求值子表达式<左>
2. 如果结果是真值v，则表达式求值为v
3. 否则，表达式求值为子表达式<右>的值

求值表达式not <表达式>：
1. 求值<表达式>；如果结果是假值，则值为True，否则为False

这些值、规则和运算符为我们提供了组合比较结果的方法。执行比较并返回布尔值的函数通常以is开头（后面不跟下划线，如isfinite、isdigit、isinstance等）。
#### 5. 迭代
迭代控制结构是多次执行相同语句的另一种机制。
while子句包含一个头部表达式和随后的代码块：
```python
while <expression>:
    <suite>
```
执行while子句：
1. 求值头部表达式
2. 如果是真值，执行代码块，然后返回步骤1

在步骤2中，while子句的整个代码块执行完毕后，头部表达式才会被再次求值。
为了防止while子句的代码块无限执行，代码块在每次循环中应该总是改变某些绑定。
不终止的while语句称为无限循环。按`<Control>-C`强制Python停止循环。
#### 6. 测试
测试函数是验证函数行为是否符合预期的行为。
测试是一种系统化执行这种验证的机制。测试通常采用另一种函数的形式，其中包含对被测函数的一个或多个示例调用。然后将返回值与预期结果进行比对验证。与大多数旨在通用的函数不同，测试涉及选择并验证具有特定参数值的调用。测试也充当文档的作用：它们展示如何调用函数以及哪些参数值是合适的。
断言：程序员使用assert语句来验证期望，例如被测试函数的输出。assert语句包含一个布尔上下文中的表达式，后面跟着一行引用的文本（单引号或双引号都可以，但要保持一致），如果表达式求值为假值，这行文本将被显示。
当被断言的表达式求值为真值时，执行assert语句没有任何效果。当它为假值时，assert会导致错误并停止执行。
当在文件中编写Python代码（而不是直接在解释器中编写）时，测试通常写在同一个文件中或后缀为_test.py的相邻文件中。
文档测试：Python提供了一种便捷的方法，可以在函数的文档字符串中直接放置简单的测试。文档字符串的第一行应包含函数的一行描述，然后是空行。接下来可能是参数和行为的详细描述。此外，文档字符串可以包含调用函数的交互式会话示例：
然后，可以通过doctest模块验证这些交互。
`testmod()`函数返回全局环境的表示，解释器需要这个表示来求值表达式。
```python
>>> from doctest import testmod
>>> testmod()
TestResults(failed=0, attempted=2)
```
要仅验证单个函数的文档测试交互，我们使用名为run_docstring_examples的doctest函数。这个函数调用起来（不幸的是）有点复杂。它的第一个参数是要测试的函数。第二个参数应该总是globals()表达式的结果，这是一个返回全局环境的内置函数。第三个参数是True，表示我们希望"详细"输出：所有运行测试的目录。
```python
>>> from doctest import run_docstring_examples
>>> run_docstring_examples(sum_naturals, globals(), True)
Finding tests in NoName
Trying:
    sum_naturals(10)
Expecting:
    55
ok
Trying:
    sum_naturals(100)
Expecting:
    5050
ok
```
当函数的返回值与预期结果不匹配时，run_docstring_examples函数会将此问题报告为测试失败。
当在文件中编写Python代码时，可以通过使用doctest命令行选项启动Python来运行文件中的所有文档测试：
```
python3 -m doctest <python源文件>
```
有效测试的关键是在实现新函数后立即编写（并运行）测试。甚至在实现之前就编写一些测试也是良好的实践，以便在脑海中有一些示例输入和输出。应用于单个函数的测试称为单元测试。详尽的单元测试是良好程序设计的标志。
### 1.6 Higher-Order Functions
#### 1. 高阶函数
我们需要构建能够接受其他函数作为参数或将函数作为返回值返回的函数。这种操作函数的函数被称为高阶函数。
通过高阶函数，我们开始看到一种更强大的抽象：有些函数表达了通用的计算方法，这些方法独立于它们调用的具体函数。
尽管函数的概念含义得到了扩展，但我们用于求值调用表达式的环境模型能优雅地扩展到高阶函数的情况，无需任何修改。当用户自定义函数应用于某些参数时，形式参数会在新的局部框架中绑定到这些参数的值（这些值可能是函数）。
#### 2. 函数的嵌套定义
将函数定义放在其他函数体内部。
与局部赋值类似，局部def语句只影响当前的局部框架
词法作用域：局部定义的函数还可以访问它们被定义时所处作用域中的名称绑定。
我们需要对环境模型进行两个扩展以实现词法作用域：
1. 每个用户定义的函数都有一个父环境：即它被定义时所处的环境。
2. 当用户定义的函数被调用时，它的局部框架扩展了它的父环境

函数值现在都有一个新的注解，我们将从现在起包含在环境图中：父环境。函数值的父环境是该函数被定义时所处环境的第一个框架。没有父环境注解的函数是在全局环境中定义的。当用户定义的函数被调用时，创建的框架与该函数具有相同的父环境。
扩展环境：环境可以包含任意长的框架链，总是以全局框架结束
因此，我们实现了Python词法作用域的两个关键优势：
- 局部函数的名称不会干扰其定义函数外部的名称，因为局部函数名称将绑定在它被定义的当前局部环境中，而不是全局环境中。
- 局部函数可以访问外层函数的环境，因为局部函数体是在扩展其定义时的求值环境的环境中求值的。

局部定义的函数通常被称为闭包。
#### 3. 柯里化
我们可以使用高阶函数将一个接受多个参数的函数转换为一系列每个只接受单个参数的函数链。更具体地说，给定函数f(x, y)，我们可以定义一个函数g，使得g(x)(y)等价于f(x, y)。这里的g是一个高阶函数，它接受单个参数x并返回另一个接受单个参数y的函数。这种转换称为柯里化。
我们手动对函数执行了柯里化转换以得到。相反，我们可以定义函数来自动执行柯里化以及逆反柯里化转换
#### 4. lambda表达式
到目前为止，每当我们想要定义一个新函数时，都需要给它一个名称。但对于其他类型的表达式，我们不需要将中间值与名称关联起来。也就是说，我们可以计算`a*b + c*d`，而无需命名子表达式`a*b`或`c*d`，或者整个表达式。
在Python中，我们可以使用lambda表达式即时创建函数值，这些lambda表达式会求值为未命名的函数。lambda表达式求值为一个以单个返回表达式作为其主体的函数。不允许使用赋值和控制语句。
我们可以通过构建相应的英文句子来理解lambda表达式的结构
```
    lambda       x            :          f(g(x))
"一个函数，它    接受x       并返回        f(g(x))"
```
lambda表达式的结果称为lambda函数。它没有内在的名称（因此Python会打印`<lambda>`作为其名称），但在其他方面，它的行为与其他函数一样。
一般来说，Python风格更倾向于显式的def语句而不是lambda表达式，但在需要简单函数作为参数或返回值的情况下允许使用lambda表达式。
#### 5. 一等地位
一般来说，编程语言对计算元素的操作方式施加限制。具有最少限制的元素被称为具有一等地位。一等元素的一些"权利和特权"包括：
1. 它们可以绑定到名称。
2. 它们可以作为参数传递给函数。
3. 它们可以作为函数的结果返回。
4. 它们可以包含在数据结构中。

Python赋予函数完全的一等地位，由此带来的表达能力提升是巨大的。
#### 6. 函数装饰器
Python提供了特殊的语法，用于在def语句执行过程中应用高阶函数，称为装饰器。
装饰器符号@后面也可以跟一个调用表达式。@后面的表达式首先被求值（就像上面的trace名称被求值一样），然后def语句被求值，最后装饰器表达式的结果应用于新定义的函数，并将结果绑定到def语句中的名称。
### 1.7 Recursive Functions
#### 1. 递归函数
如果一个函数的函数体直接或间接地调用了函数本身，那么这个函数就被称为递归函数。也就是说，执行递归函数体的过程可能需要再次应用该函数。
在许多递归函数的函数体中，我们可以发现一个共同的模式。函数体以一个基本情况开始，这是一个条件语句，定义了函数对于最简单输入的处理行为
基本情况之后跟着一个或多个递归调用。递归调用通常具有某种特征：它们简化了原始问题。递归函数通过逐步简化问题来表达计算。
递归函数利用求值调用表达式的规则来绑定名称到值，通常避免了在迭代过程中正确分配局部名称的麻烦。因此，递归函数可能更容易正确定义。
#### 2. 相互递归
当递归过程被划分为两个相互调用的函数时，这些函数被称为相互递归。
#### 3. 树递归
函数多次调用自身
___
[返回目录](#目录)
___
## Chapter 2: Building Abstractions with Data<a id = "chapter2"></a>
### 1.1 Introduction
Python 中的每个值都有一个决定其类型的类。属于同一类的值具有相同的行为特征。
#### 1. 原生数据类型
到目前为止，我们使用的值都属于 Python 内置的少量原生数据类型的实例。原生数据类型具有以下特性：
1. 存在可直接计算为原生类型值的表达式，称为字面量。
2. 有内置函数和操作符来处理原生类型的值。

Python 包含三种原生数值类型：整数（int）、浮点数（float）和复数（complex）
1. 整数：`int`类是用于表示整数的原生数据类型。整数字面量（连续数字序列）会计算为`int`值，数学运算符可操作这些值。
2. 浮点数：`float`的名称源于Python和许多其他编程语言中实数的表示方式——"浮点"表示法。`int`对象可以精确表示整数，没有大小限制；而`float`对象可以表示广泛的分数，但并非所有数字都能精确表示，并且存在最小值和最大值限制。因此，`float`值应被视为真实值的近似，这些近似值只有有限的精度。组合浮点值可能导致近似误差

非数值类型：值可以表示许多其他类型的数据，如声音、图像、位置、网址、网络连接等。少数由原生数据类型表示，如表示 True 和 False 值的 bool 类。大多数值的类型必须由程序员通过本章将介绍的组合和抽象方法来定义。
### 2.2 Data Abstraction
#### 1. 数据抽象
将处理数据表示方式的程序部分与处理数据操作方式的程序部分相隔离的通用技术，是一种强大的设计方法，称为数据抽象。数据抽象使程序的设计、维护和修改变得更加容易。
数据抽象在性质上与函数抽象相似。当我们创建函数抽象时，可以隐藏函数的具体实现细节，并且该特定函数可以被任何具有相同整体行为的其他函数替代。换句话说，我们可以建立一种抽象，将函数的使用方式与其实现细节分离开来。类似地，数据抽象将复合数据值的使用方式与其构建细节相隔离。
数据抽象的基本思想是构建程序，使其操作于抽象数据之上。也就是说，我们的程序应尽可能少地对数据做出假设来使用数据。同时，具体的数据表示被定义为程序中独立的部分。
程序的这两个部分——操作抽象数据的部分和定义具体表示的部分——通过一小组函数连接起来，这些函数基于具体表示来实现抽象数据。
#### 2. 抽象屏障
数据抽象的核心思想是：确定一组基本操作，所有对某种类型值的操作都将通过这些操作来表达，然后在操作数据时仅使用这些操作。通过以这种方式限制操作的使用，我们可以更容易地改变抽象数据的表示方式，而不会改变程序的行为。
抽象屏障：函数由更高层级调用，并使用更低层级的抽象来实现。
每当程序中能够使用更高层级函数的部分却使用了更低层级的函数时，就会发生抽象屏障破坏
抽象屏障使程序更易于维护和修改
#### 3. 抽象数据的性质
我们可以通过一组选择器、构造函数以及一些行为条件来表达抽象数据。只要行为条件得到满足（如上述除法属性），选择器和构造函数就构成了对某种数据的有效表示。抽象屏障下的实现细节可以改变，但只要行为不变，数据抽象就保持有效，任何使用该数据抽象编写的程序也将保持正确。
### 2.3 Sequences
序列是一个有序的值集合。序列是计算机科学中一个强大而基础的抽象概念。序列并非某个特定内置类型或抽象数据表示的实例，而是在多种不同类型的数据之间共享的行为集合。也就是说，存在多种序列类型，但它们都共享一些共同的行为特征。具体来说：
- 长度：序列具有有限长度。空序列的长度为 0。
- 元素选择：对于任何小于其长度的非负整数索引（从 0 开始代表第一个元素），序列都有对应的元素。
#### 1. 列表
为了让我们能够实现数据抽象的具体层面，Python 提供了一种称为列表的复合结构，可以通过在方括号内放置用逗号分隔的表达式来构建。这样的表达式称为列表字面量。
列表的元素可以通过两种方式访问：
1. 多重赋值方法，它将列表解包为其元素，并将每个元素绑定到不同的名称。
2. 使用元素选择运算符，同样使用方括号表示。与列表字面量不同，紧跟在另一个表达式后面的方括号表达式并不计算为列表值，而是从前面的表达式值中选择一个元素。

Python 中的列表（以及大多数其他编程语言中的序列）是从0开始索引的，这意味着索引0选择第一个元素，索引1选择第二个元素，依此类推。支持这种索引约定的一个直观理解是：索引表示元素距离列表开头的偏移量。
元素选择运算符对应的函数称为`getitem`，它同样使用从0开始的位置索引从列表中选择元素。
内置的`len`函数返回序列的长度。
此外，列表可以相互相加，也可以与整数相乘。对于序列而言，加法和乘法并非对元素进行相加或相乘，而是组合和复制序列本身
任何值都可以包含在列表中，包括另一个列表。可以通过多次应用元素选择操作来选择包含列表的列表中深层嵌套的元素。
#### 2. 序列迭代
在许多情况下，我们希望遍历序列中的元素，并依次对每个元素执行某种计算。这种模式非常普遍，因此 Python 提供了一种专门用于处理序列数据的控制语句：`for`语句。
`for`语句由以下形式的单个子句组成：
```python
for <name> in <expression>:
    <suite>
```
for 语句按以下过程执行：
1. 计算头部的`<expression>`，它必须产生一个可迭代的值。
2. 按顺序对该可迭代值中的每个元素值：
   1. 在当前帧中将`<name>`绑定到该值。
   2. 执行`<suite>`。

此执行过程涉及可迭代值。列表是一种序列类型，而序列是可迭代值，它们的元素按顺序处理。
该求值过程的一个重要结果是：在`for`语句执行后，`<name>`将绑定到序列的最后一个元素。`for`循环引入了另一种可以通过语句更新环境的方式。
序列解包：程序中的一个常见模式是拥有一个元素本身也是序列的序列，且所有子序列长度固定。for 语句的头部可以包含多个名称，以将每个元素序列"解包"到各自的元素中。
#### 3. 范围
range 是 Python 中另一种内置序列类型，表示一个整数范围。范围由 range 创建，它接受两个整数参数：起始数字和所需范围的最后一个数字的后一个数字。
对范围调用列表构造函数会计算出一个与范围具有相同元素的列表，从而可以轻松查看元素
如果只给出一个参数，它被解释为从 0 开始的范围的最后一个值的后一个数字
范围通常作为`for`头部的表达式出现，用于指定`<suite>`应执行的次数。一个常见约定是：如果在`<suite>`中不使用名称，则在`for`头部使用单个下划线字符作为名称。就解释器而言，这个下划线只是环境中的另一个名称，但在程序员中具有约定俗成的含义，表示该名称不会出现在任何未来的表达式中。
#### 4. 列表推导式
许多序列处理操作可以通过对序列中的每个元素求值一个固定表达式，并将结果值收集到结果序列中来完成。在 Python 中，列表推导式就是执行此类计算的表达式。
列表推导式的一般形式为：
```python
[<map expression> for <name> in <sequence expression> if <filter expression>]
```
为了计算列表推导式，Python 会先计算`<sequence expression>`，它必须返回一个可迭代的值。然后按顺序对每个元素，将元素值绑定到`<name>`，计算`<filter expression>`，如果结果为真值，则计算`<map expression>`。`<map expression>`的值被收集到一个列表中。
#### 5. 聚合
将序列中的所有值聚合成一个单一值。内置函数 sum、min 和 max 都是聚合函数的例子。
#### 6. 成员检查和切片
成员检查：可以测试一个值是否是序列的成员。Python 提供了两个运算符`in`和`not in`，根据元素是否出现在序列中，计算结果为 True 或 False。
切片：序列中包含更小的序列。序列的切片是原始序列中的任何连续片段，由一对整数指定。与范围构造函数一样，第一个整数表示切片的起始索引，第二个整数表示切片结束索引的后一个位置。
在 Python 中，序列切片使用与元素选择类似的方括号表示法。冒号分隔起始和结束索引。任何被省略的边界都会被假定为极值：起始索引默认为 0，结束索引默认为序列的长度。
#### 7. 字符串
Python 中文本的原生数据类型称为字符串，对应于构造函数`str`。
字符串字面量可以表达任意文本，用单引号或双引号包围
字符串的元素本身也是字符串，但只包含单个字符。字符是任何单个字母、标点符号或其他符号。与许多其他编程语言不同，Python 没有单独的字符类型；任何文本都是字符串，表示单个字符的字符串长度为 1。
与列表类似，字符串也可以通过加法和乘法进行组合
成员检查：字符串的行为与 Python 中的其他序列类型有所不同。字符串抽象并不完全符合我们为列表和范围描述的全序列抽象。具体来说，成员运算符 in 可以应用于字符串，但其行为与应用于序列时完全不同：它匹配的是子字符串，而不是单个元素。
多行字面量：字符串不限于单行。三重引号用于分隔跨越多行的字符串字面量。我们在文档字符串中已经广泛使用了这种三重引号。
`\n`是一个表示换行的单个元素。虽然它看起来像两个字符（反斜杠和“n”），但在长度和元素选择中，它被视为单个字符。
字符串强制转换：可以通过调用 str 构造函数并将对象值作为参数，从 Python 中的任何对象创建字符串。字符串的这一特性可用于从各种类型的对象构造描述性字符串。
#### 8. 树
我们能够将列表作为其他列表的元素使用，这为我们的编程语言提供了一种新的组合方式。这种能力被称为数据类型的闭包性质。一般来说，如果组合数据值的方法产生的结果本身可以使用相同的方法进行组合，那么该方法就具有闭包性质。闭包是任何组合方式中产生强大能力的关键，因为它允许我们创建层次结构——即由部分组成的结构，而这些部分本身又由更小的部分组成，依此类推。
一棵树有一个根标签和一系列分支。树的每个分支本身也是一棵树。没有分支的树称为叶子。任何包含在树内的树都称为该树的子树（例如分支的分支）。树的每个子树的根称为该树的节点。
树的数据抽象包括构造函数 tree 以及选择器 label 和 branches。我们从一个简化版本开始：
```python
>>> def tree(root_label, branches=[]):
        for branch in branches:
            assert is_tree(branch), 'branches must be trees'
        return [root_label] + list(branches)
>>> def label(tree):
        return tree[0]
>>> def branches(tree):
        return tree[1:]
```
只有当一个树具有根标签并且所有分支也都是树时，它才是结构良好的。is_tree 函数在 tree 构造函数中被调用，以验证所有分支是否结构良好。is_leaf 函数检查树是否有分支
```python
>>> def is_tree(tree):
        if type(tree) != list or len(tree) < 1:
            return False
        for branch in branches(tree):
            if not is_tree(branch):
                return False
        return True
>>> def is_leaf(tree):
        return not branches(tree)
```
其他构造树的方法：
1. 嵌套表达式
2. 树递归函数

处理树的方法：树递归
#### 9. 链表
链表是一个包含序列的第一个元素和序列的其余部分的"对"。
链表具有递归结构：链表的其余部分要么是一个链表，要么是'empty'。
```python
>>> empty = 'empty'
>>> def is_link(s):
        """如果 s 是空链表或一个 (first, rest) 对，则 s 是一个链表。"""
        return s == empty or (len(s) == 2 and is_link(s[1]))
>>> def link(first, rest):
        """根据第一个元素和其余部分构造一个链表。"""
        assert is_link(rest), "rest must be a linked list."
        return [first, rest]
>>> def first(s):
        """返回链表 s 的第一个元素。"""
        assert is_link(s), "first only applies to linked lists."
        assert s != empty, "empty linked list has no first element."
        return s[0]
>>> def rest(s):
        """返回链表 s 的其余元素。"""
        assert is_link(s), "rest only applies to linked lists."
        assert s != empty, "empty linked list has no rest."
        return s[1]
```
link 是一个构造函数，first 和 rest 是链表抽象数据表示的选择器。链表的行为条件是，与"对"类似，其构造函数和选择器是互逆函数：
如果链表 s 是由第一个元素 f 和链表 r 构造的，那么 first(s) 返回 f，rest(s) 返回 r。
递归构造：链表在增量构造序列时特别有用，这种情况在递归计算中经常出现。
### 2.4 Mutable Data
构建模块化程序的一项重要技术，是引入随时间变化的状态数据。通过这种方式，一个独立的数据对象能够表征那些与程序其他部分并行演进的实体。如同现实世界中的事物，这些可变对象的行为往往会受到其历史状态的影响。为数据添加状态，正是面向对象编程范式的核心要素之一。
#### 1. 对象
函数执行操作，而数据则是被操作的对象。当我们将函数值纳入数据范畴时，意味着我们认识到数据本身也可以具有行为。函数既能作为数据被操作，也能被调用来执行计算。
对象将数据值与行为结合起来。对象不仅表示信息，还展现出其所代表事物的行为方式。与其他对象交互的逻辑，与编码对象值的信息一起被打包封装。当一个对象被打印时，它知道如何将自己以文本形式拼写出来。如果对象由多个部分组成，它知道如何按需展示这些部分。对象既是信息也是过程，它们被打包在一起，以表示复杂事物的属性、交互与行为。
对象具有属性，这些属性是对象的一部分，是具有名称的值。在Python中，如同许多其他编程语言一样，我们使用点符号来指定对象的属性。
```python
<expression> . <name>
```
上面，`<expression>`的计算结果是一个对象，而`<name>`是该对象属性的名称。
与我们目前所考虑的名称不同，这些属性名称并不在全局环境中可用。相反，属性名称是特定于点符号前面的对象实例的。
对象还具有方法，这些是函数值的属性。形象地说，对象"知道"如何执行这些方法。在实现上，方法是函数，它们从参数及其所属的对象中计算结果。
事实上，Python中的所有值都是对象。也就是说，所有值都具有行为和属性。它们的行为就像它们所代表的值那样。
#### 2. 可变对象
可变对象用于表示随时间变化的值。
对象可能因修改操作而具有变化的属性。
列表对象属于可变对象
大多数改变是通过调用列表对象的方法来执行的。
用于插入、排序和反转列表的方法。所有这些修改操作都改变了列表的值；它们不创建新的列表对象。
因为我们一直在修改单个列表而不是创建新列表，所以绑定到同一列表的两个名称所对应的列表都发生了变化，即对于可变数据，在一个名称上调用的方法可以同时影响另一个名称。
测试两个对象是否是同一个对象。Python包含两个比较运算符is和is not，用于测试两个表达式是否求值为完全相同的对象。如果两个对象当前值相等，并且对其中一个的任何更改总是会反映在另一个中，那么它们就是相同的。身份是比相等性更强的条件。
`is`和`==`之间的区别：前者检查身份，而后者检查内容的相等性。
列表推导式总是创建一个新列表。
#### 3. 元组
元组是内置tuple类型的实例，是不可变序列。元组使用元组字面量创建，通过逗号分隔元素表达式，放在括号中
空元组和单元素元组有特殊的字面量语法：
```python
>>> ()    # 0 elements
()
>>> (10,) # 1 element
(10,)
```
元组具有有限长度并支持元素选择
然而，用于操作列表内容的方法不适用于元组，因为元组是不可变的。
虽然无法更改元组中包含哪些元素，但可以更改元组内包含的可变元素的值。
元组在多重赋值中被隐式使用。将两个值赋给两个名称会创建一个二元组，然后将其解包。
#### 4. 字典
字典是Python内置的数据类型，用于存储和处理对应关系。一个字典包含键-值对，其中键和值都是对象。字典的目的是提供一种抽象机制，用于存储和检索那些不是通过连续整数索引，而是通过描述性键索引的值。
字符串通常作为键，因为字符串是我们表示事物名称的常规方式。
通过键查找值使用我们先前应用于序列的元素选择运算符。
一个字典对每个键最多只能有一个值。添加新的键-值对和更改现有键的值都可以通过赋值语句实现。
当我们打印字典时，键和值会以某种顺序呈现，但作为语言使用者，我们无法预测该顺序是什么。顺序可能会在多次运行程序时发生变化。
字典类型还支持多种方法来遍历字典的全部内容。方法keys、values和items都返回可迭代的值。
键-值对的列表可以通过调用dict构造函数转换为字典
字典确实有一些限制：
- 字典的键不能是可变的，也不能包含可变值。
- 对于一个给定的键，最多只能有一个值。

第一个限制与Python中字典的底层实现有关。该实现的细节不在本文的讨论范围内。直观地说，考虑键告诉Python在内存中何处找到该键-值对；如果键发生变化，该对的位置可能会丢失。元组通常用作字典的键，因为列表不能用作键。
第二个限制是字典抽象的结果，该抽象旨在存储和检索键对应的值。只有当字典中最多存在一个这样的值时，我们才能检索到该键的值。
字典实现的一个有用方法是get，如果键存在，则返回键对应的值，否则返回默认值。get的参数是键和默认值。
字典也有类似于列表的推导式语法。键表达式和值表达式之间用冒号分隔。求值字典推导式会创建一个新的字典对象。
#### 5. 局部状态
列表和字典具有局部状态：它们是变化的值，在程序执行的任何时间点都有其特定的内容。"状态"这个词意味着一个不断演变的过程，其中状态可能发生变化。
函数也可以有局部状态
#### 6. 非局部赋值
nonlocal 是 Python 中用于在嵌套函数内部修改外层（非全局）作用域变量的关键字。用于声明一个变量不是局部的，而是来自外层嵌套函数作用域
nonlocal语句表示该名称出现在环境中除第一个（局部）框架或最后一个（全局）框架之外的某个地方。
通过引入nonlocal语句，我们赋予了赋值语句双重角色。它们要么更改局部绑定，要么更改非局部绑定。事实上，赋值语句已经具有双重角色：它们要么创建新的绑定，要么重新绑定已存在的名称。赋值还可以改变列表和字典的内容。Python赋值的多种角色可能会模糊执行赋值语句的效果。作为程序员，您有责任清晰地记录您的代码，以便其他人能够理解赋值的效果。
Python在名称查找方面还有一个不寻常的限制：在函数体内，一个名称的所有实例都必须引用同一个框架。因此，Python不能在非局部框架中查找一个名称的值，然后在局部框架中绑定同一个名称，因为同一个名称会在同一个函数的两个不同框架中被访问。
非局部赋值是我们将程序视为独立自主对象集合的重要一步，这些对象相互交互，但各自管理自己的内部状态。
具体来说，非局部赋值使我们能够维护一些对函数来说是局部的状态，但该状态会随着对该函数的连续调用而演变
#### 7. 调度函数
调度函数是实现抽象数据消息传递接口的通用方法。为了实现消息分发，我们目前使用了条件语句来比较消息字符串和一组固定的已知消息。
#### 8. 声明式编程
可变数据使我们能够模拟具有变化的系统，同时也允许我们构建新型的抽象。
将程序表达为约束是一种声明式编程，在这种编程中，程序员声明待解决问题的结构，但抽象掉了问题解决方案如何计算的具体细节。
### 2.5 Object-Oriented Programming
#### 1. 对象
类作为其所有对象的类型模板。每个对象都是某个特定类的实例。我们迄今为止使用的对象都具有内置类，但用户同样可以创建新的自定义类。类定义明确了该类别对象共享的属性和方法。
创建新对象实例的行为称为类的实例化。在Python中实例化类的语法与调用函数的语法完全相同。
对象属性是与对象关联的命名值对，可通过点符号访问。特定于某个对象（而非类所有对象）的属性称为实例属性。
在更广泛的编程领域中，实例属性也可称为字段、属性或实例变量。
作用于对象或执行对象特定计算的函数称为方法。方法的返回值及副作用可能依赖于并改变对象的其他属性。
#### 2. 定义类
用户自定义类通过 class 语句创建，该语句由单个子句构成。class 语句定义了类名，并包含一个语句块来定义类的属性：
```python
class <name>:
    <suite>
```
当`class`语句执行时，会在当前环境的第一帧中创建一个新类并将其绑定到`<name>`。随后执行语句块。在类语句的`<suite>`中通过`def`或赋值语句绑定的任何名称，都会创建或修改类的属性。
类通常围绕操作实例属性来组织，这些属性是与该类的每个实例相关联的名称-值对。类通过定义初始化新对象的方法来指定其对象的实例属性。
类语句的`<suite>`包含的`def`语句定义了该类对象的新方法。初始化对象的方法在 Python 中有特殊名称`__init__`（"init" 单词两侧各有两个下划线），被称为类的构造函数。
`__init__`方法的第一个参数`self`绑定到新创建的对象。其他参数绑定到实例化类时传递给类的参数。
标识：每个实例都有自己的属性，其值独立于同一类的其他对象
为了确保这种分离，每个用户自定义类的实例对象都具有唯一标识。对象标识使用 is 和 is not 运算符进行比较
尽管通过相同的调用构造，绑定到 a 和 b 的对象并不相同。通常，使用赋值将对象绑定到新名称不会创建新对象
只有当类通过调用表达式语法实例化时，才会创建具有用户自定义类的新对象。
方法：对象方法也由类语句块中的 def 语句定义。
虽然方法定义在声明方式上与函数定义没有区别，但方法定义在执行时具有不同的效果。在类语句中通过 def 语句创建的函数值会绑定到声明的名称，但作为属性局部绑定在类中。该值通过点符号从类的实例作为方法调用。
#### 3. 点表达式
定义在类中的方法和通常在构造函数中分配的实例属性是面向对象编程的基本要素。这两个概念复现了数据值在消息传递实现中分发字典的大部分行为。对象使用点符号接收消息，但这些消息不是任意的字符串值键，而是类本地的名称。对象也具有命名的局部状态值（实例属性），但该状态可以使用点符号访问和操作，而无需在实现中使用 nonlocal 语句。
消息传递的核心思想是数据值应通过响应与其代表的抽象类型相关的消息来体现行为。点符号是 Python 的语法特性，它形式化了消息传递的隐喻。使用具有内置对象系统的语言的优势在于，消息传递可以与其他语言特性（如赋值语句）无缝交互。我们不需要不同的消息来"获取"或"设置"与局部属性名关联的值；语言语法允许我们直接使用消息名称。
点表达式由表达式、点和名称组成：
```python
<expression> . <name>
```
`<expression>`可以是任何有效的 Python 表达式，但`<name>`必须是简单名称（而不是计算结果为名称的表达式）。点表达式求值为给定`<name>`的属性值，该属性属于`<expression>`值所代表的对象。
内置函数 getattr 也通过名称返回对象的属性。它是点符号的函数等价形式。使用 getattr，我们可以使用字符串查找属性，就像使用分发字典一样
我们还可以使用 hasattr 测试对象是否具有某个命名属性
对象的属性包括其所有实例属性，以及在其类中定义的所有属性（包括方法）。方法是需要特殊处理的类属性。
方法与函数：当在对象上调用方法时，该对象隐式地作为第一个参数传递给方法。也就是说，点符号左侧`<expression>`的值所代表的对象会自动作为第一个参数传递给点表达式右侧命名的方法。因此，对象绑定到参数 self。
为了实现自动的 self 绑定，Python 区分了函数（我们从文本开始就一直创建）和绑定方法（将函数与调用该方法的对象耦合在一起）。绑定方法值已经与其第一个参数（调用它的实例）关联，当方法被调用时，该参数将被命名为 self。
命名约定：类名通常使用大驼峰命名法（也称为 CamelCase，因为名称中间的大写字母看起来像驼峰）。方法名遵循使用下划线分隔的小写单词命名函数的标准约定。
在某些情况下，存在与对象的维护和一致性相关的实例变量和方法，我们不希望对象的使用者看到或使用它们。它们不是类定义的抽象的一部分，而是实现的一部分。Python 的约定规定，如果属性名以下划线开头，则只应在类自身的方法中访问，而不应由类的使用者访问。
#### 4. 类属性
某些属性值在给定类的所有对象之间共享。这些属性与类本身关联，而不是与类的任何单个实例关联。
类属性通过在类语句块中、在任何方法定义之外的赋值语句创建。在更广泛的开发社区中，类属性也可称为类变量或静态变量。
该属性仍可从类的任何实例访问
然而，对类属性的单个赋值语句会改变该属性对所有类实例的值
属性名称查找：我们的对象系统已引入足够的复杂性，因此必须明确名称如何解析为特定属性。毕竟，我们很容易拥有同名的类属性和实例属性。
如前所述，点表达式由表达式、点和名称组成：
```python
<expression> . <name>
```
点表达式的求值过程：
1. 求值点左边的 <表达式>，得到点表达式的对象
2. <名称> 与该对象的实例属性匹配；如果存在该名称的属性，则返回其值
3. 如果 <名称> 未出现在实例属性中，则在类中查找 <名称>，得到类属性值
4. 返回该值，除非它是函数，在这种情况下返回绑定方法

在此求值过程中，实例属性优先于类属性被找到
属性赋值：所有左侧包含点表达式的赋值语句都会影响该点表达式对象的属性。如果对象是实例，则赋值设置实例属性；如果对象是类，则赋值设置类属性。因此，对对象属性的赋值不能影响其类的属性。
#### 5. 继承
在面向对象编程范式下工作时，我们经常发现不同类型之间存在关联。特别是，我们发现相似类在专化程度上存在差异。两个类可能具有相似的属性，但一个类代表另一个类的特殊情况。
除了作为有用的组织功能外，继承在我们的对象隐喻中也扮演着重要角色。继承旨在表示类之间的 "是一个"（is-a） 关系，这与 "有一个"（has-a） 关系形成对比。
我们通过在类名后的括号中放入求值为基类的表达式来指定继承
在类中查找名称：
1. 如果该名称是类中的属性，则返回属性值
2. 否则，在基类中查找该名称（如果存在基类）

对象的类保持不变。
调用父类方法：已被覆盖的属性仍然可以通过类对象访问。
接口：在面向对象程序中，不同类型的对象共享相同的属性名称是非常常见的。对象接口是属性及其条件的集合。
如果程序的某些部分（使用对象而非实现对象）不对对象类型做任何假设，而只对其属性名称做假设，那么这些部分对未来更改的适应性最强。也就是说，它们使用对象抽象，而不是对其实现做任何假设。
多重继承：Python 支持子类从多个基类继承属性的概念，这一语言特性称为多重继承。
#### 6. 类的作用
Python的对象系统旨在使数据抽象和消息传递既便捷又灵活。类、方法、继承和点表达式的专门语法使我们能够在程序中形式化对象隐喻，从而提高我们组织大型程序的能力。
特别是，我们希望对象系统能促进程序中不同关注点的分离。程序中的每个对象封装并管理程序状态的某些部分，每个类语句定义实现程序整体逻辑某些部分的函数。抽象屏障强制执行大型程序中不同方面之间的边界。
面向对象编程特别适合建模具有独立但交互部分的系统。例如，不同用户在社交网络中互动，不同角色在游戏中互动，不同形状在物理模拟中互动。当表示此类系统时，程序中的对象通常自然地映射到被建模系统中的对象，而类表示它们的类型和关系。
另一方面，类可能并非实现某些抽象的最佳机制。函数抽象为表示输入和输出之间的关系提供了更自然的隐喻。不应强求将程序中的每一点逻辑都纳入类中，特别是在定义用于操作数据的独立函数更自然时。函数也能强制执行关注点分离。
像Python这样的多范式语言允许程序员将组织范式与适当的问题相匹配。学习识别何时引入新类（而不是新函数）以简化或模块化程序，是软件工程中值得仔细关注的重要设计技能。
### 2.6 Implementing Classes and Objects
在面向对象编程范式下工作时，我们使用对象隐喻来指导程序的组织。关于如何表示和操作数据的大部分逻辑都在类声明中表达。在本节中，我们将看到类和对象本身可以仅使用函数和字典来表示。以这种方式实现对象系统的目的是说明：使用对象隐喻并不需要特殊的编程语言。即使在那些没有内置对象系统的编程语言中，程序也可以是面向对象的。
为了实现对象，我们将放弃点符号（这确实需要内置语言支持），而是创建行为方式与内置对象系统元素非常相似的分发字典。我们已经看到了如何通过分发字典实现消息传递行为。为了完整实现对象系统，我们在实例、类和基类之间发送消息，所有这些都包含属性的字典。
我们不会实现整个Python对象系统，其中包括本文未涵盖的特性（例如元类和静态方法）。相反，我们将专注于没有多重继承和没有内省行为（例如返回实例的类）的用户自定义类。我们的实现并非旨在遵循Python类型系统的精确规范，而是设计为实现支持对象隐喻的核心功能。
#### 1. 实现实例
我们首先从实例开始。实例具有命名属性，例如账户余额，可以设置和获取。我们使用一个分发字典来实现实例，该字典响应"获取"和"设置"属性值的消息。属性本身存储在一个名为 attributes 的局部字典中。
正如我们在本章前面所见，字典本身就是抽象数据类型。我们用列表实现了字典，用点对实现了列表，用函数实现了点对。当我们基于字典实现对象系统时，请记住，我们同样可以仅使用函数来实现对象。
开始实现时，我们假设有一个类实现，可以查找不属于实例的任何名称。我们将一个类作为参数 cls 传递给 make_instance。
```python
>>> def make_instance(cls):
        """返回一个新的对象实例，它是一个分发字典。"""
        def get_value(name):
            if name in attributes:
                return attributes[name]
            else:
                value = cls['get'](name)
                return bind_method(value, instance)
        
        def set_value(name, value):
            attributes[name] = value
        
        attributes = {}
        instance = {'get': get_value, 'set': set_value}
        return instance
```
实例是一个响应 get 和 set 消息的分发字典。set 消息对应于 Python 对象系统中的属性赋值：所有被赋值的属性直接存储在对象的局部属性字典中。在 get 中，如果 name 没有出现在局部 attributes 字典中，则在类中查找。如果 cls 返回的值是一个函数，则必须将其绑定到实例。
绑定方法值：make_instance 中的 get_value 函数使用 get 在其类中查找命名属性，然后调用 bind_method。绑定方法仅适用于函数值，它通过将实例作为第一个参数插入，从函数值创建绑定方法值：
```python
>>> def bind_method(value, instance):
        """如果value是可调用的，则返回绑定方法，否则返回值本身。"""
        if callable(value):
            def method(*args):
                return value(instance, *args)
            return method
        else:
            return value
```
根据此定义，当调用方法时，第一个参数 self 将绑定到 instance 的值。
#### 2. 实现类
类也是一个对象，无论是在Python的对象系统中还是在我们这里实现的系统中。为简化起见，我们称类本身没有类（在Python中，类确实有类；几乎所有类共享同一个类，称为type）。类可以响应get和set消息，以及new消息：
```python
>>> def make_class(attributes, base_class=None):
        """返回一个新类，它是一个分发字典。"""
        def get_value(name):
            if name in attributes:
                return attributes[name]
            elif base_class is not None:
                return base_class['get'](name)
        
        def set_value(name, value):
            attributes[name] = value
        
        def new(*args):
            return init_instance(cls, *args)
        
        cls = {'get': get_value, 'set': set_value, 'new': new}
        return cls
```
与实例不同，类的get函数在找不到属性时不会查询其类，而是查询其base_class。类不需要方法绑定。
初始化：make_class中的new函数调用init_instance，它首先创建一个新实例，然后调用一个名为__init__的方法：
```python
>>> def init_instance(cls, *args):
        """返回一个类型为cls的新对象，使用args初始化。"""
        instance = make_instance(cls)
        init = cls['get']('__init__')
        if init:
            init(instance, *args)
        return instance
```
这最后一个函数完成了我们的对象系统。现在我们有了实例，它们可以本地设置属性，但在获取时回退到它们的类。实例在其类中查找名称后，将自身绑定到函数值以创建方法。最后，类可以创建新实例，并在实例创建后立即应用其__init__构造函数。
在这个对象系统中，用户应该调用的唯一函数是make_class。所有其他功能都通过消息传递启用。类似地，Python的对象系统通过class语句调用，其所有其他功能都通过点表达式和对类的调用启用。
我们基于字典构建的对象系统在实现上与Python的内置对象系统非常相似。在Python中，任何用户定义类的实例都有一个特殊属性__dict__，它将该对象的本地实例属性存储在字典中，很像我们的attributes字典。Python的不同之处在于它区分了某些特殊方法，这些方法与内置函数交互，以确保这些函数对许多不同类型的参数都能正确运行.
### 2.7 Object Abstraction
对象系统允许程序员高效地构建和使用抽象数据表示。它同时也被设计成允许多种抽象数据表示在同一程序中共存。
对象抽象的一个核心概念是泛型函数，即能够接受多种不同类型值的函数。我们将探讨实现泛型函数的三种不同技术：共享接口、类型分发和类型强制转换。在构建这些概念的过程中，我们还将发现Python对象系统中支持创建泛型函数的特性。
#### 1. 字符串
为了有效表示数据，对象值应当表现出与其所代表的数据类型相符的行为，包括生成自身的字符串表示。数据值的字符串表示在像Python这样的交互式语言中尤为重要，因为Python会在交互会话中自动显示表达式的值的字符串表示。
Python规定所有对象都应生成两种不同的字符串表示：一种是人类可解释的文本，另一种是Python可解释的表达式。字符串的构造函数str返回人类可读的字符串。在可能的情况下，repr函数返回一个求值后等于原对象的Python表达式。
在表达式的值上调用repr的结果就是Python在交互会话中打印的内容。当不存在能够求值为原始值的表示时，Python通常会产生一个用尖括号包围的描述。
str构造函数通常与repr一致，但在某些情况下提供更具解释性的文本表示。
定义repr函数带来了新的挑战：我们希望它能正确应用于所有数据类型，即使是那些在repr实现时尚未存在的数据类型。我们希望它是一个泛型或多态函数，即能够应用于多种（poly）不同形态（morph）的数据。
对象系统在这种情况下提供了一个优雅的解决方案：repr函数总是调用其参数上一个名为__repr__的方法。
通过在用户定义的类中实现同样的方法，我们可以将repr的适用性扩展到未来创建的任何类。这个例子突显了点表达式的另一个好处：它们为将现有函数的领域扩展到新的对象类型提供了机制。
str构造函数以类似的方式实现：它调用其参数上一个名为__str__的方法。
这些多态函数是一个更通用原则的例子：某些函数应当应用于多种数据类型。而且，创建此类函数的一种方法是在每个类中使用具有不同定义的共享属性名称。
#### 2. 特殊方法
在Python中，某些特殊名称会在特定情况下被Python解释器调用。例如，每当构造对象时，类的__init__方法会自动被调用。打印时__str__方法会自动调用，在交互会话中显示值时__repr__会被调用。
Python中有许多其他行为的特殊名称。下面描述了其中一些最常用的。
1. 真值和假值：我们之前看到Python中的数字具有真值；更具体地说，0是假值，所有其他数字都是真值。实际上，Python中的所有对象都有真值。默认情况下，用户定义类的对象被视为真，但可以使用特殊的__bool__方法来覆盖此行为。如果一个对象定义了__bool__方法，那么Python会调用该方法来确定其真值。
2. 序列操作：我们已经看到可以调用len函数来确定序列的长度。len函数调用其参数的__len__方法来确定长度。所有内置序列类型都实现了此方法。如果序列没有提供__bool__方法，Python会使用序列的长度来确定其真值。空序列为假，非空序列为真。__getitem__方法由元素选择运算符调用，但也可以直接调用。
3. 可调用对象：在Python中，函数是一等对象，因此它们可以作为数据传递并像任何其他对象一样具有属性。Python还允许我们定义可以通过包含__call__方法来像函数一样"调用"的对象。使用此方法，我们可以定义一个行为类似于高阶函数的类。
4. 算术运算：特殊方法还可以定义应用于用户定义对象的内置运算符的行为。为了提供这种通用性，Python遵循特定的协议来应用每个运算符。例如，为了求值包含+运算符的表达式，Python会检查表达式左右操作数的特殊方法。首先，Python检查左操作数值上的__add__方法，然后检查右操作数值上的__radd__方法。如果找到任何一个，则以另一个操作数的值作为参数调用该方法。
#### 3. 多重表示
抽象屏障允许我们分离数据的使用和表示。然而，在大型程序中，谈论程序中数据类型的"底层表示"可能并不总是有意义。一方面，数据对象可能有不止一种有用的表示，我们可能希望设计能够处理多重表示的系统。
允许数据多重表示的想法经常出现。大型软件系统通常由许多人在长时间内设计，并且需求会随时间变化。在这样的环境中，不可能让每个人都事先就数据表示的选择达成一致。除了将表示与使用隔离的数据抽象屏障外，我们还需要将不同设计选择彼此隔离并允许不同选择在单个程序中共存的抽象屏障。
接口：对象属性是消息传递的一种形式，允许不同的数据类型以不同的方式响应相同的消息。从不同类中引出类似行为的共享消息集合是一种强大的抽象方法。接口是一组共享的属性名称及其行为规范编码多重表示的接口方法具有吸引人的特性。每个表示的类可以单独开发；它们只需要就它们共享的属性名称以及这些属性的任何行为条件达成一致。接口也是可加的。如果另一个程序员想向同一程序添加复数的第三种表示，他们只需要创建另一个具有相同属性的类。
数据的多重表示与我们在本章开头介绍的数据抽象的概念密切相关。使用数据抽象，我们能够更改数据类型的实现而不改变程序的意义。使用接口和消息传递，我们可以在同一程序中有多个不同的表示。在这两种情况下，一组名称和相应的行为条件定义了实现这种灵活性的抽象。
#### 4. 泛型函数
泛型函数是应用于不同类型参数的方法或函数
使用接口和消息传递只是实现泛型函数的几种方法之一。我们将在本节中考虑另外两种：类型分发和类型强制转换
类型分发：实现跨类型操作的一种方法是根据函数或方法的参数类型选择行为。类型分发的思想是编写检查其接收参数类型的函数，然后执行适合这些类型的代码。
内置函数isinstance接受一个对象和一个类。如果对象的类是指定类或继承自指定类，则返回true。
强制转换：在完全不相关的操作作用于完全不相关的类型的一般情况下，实现显式的跨类型操作，尽管可能繁琐，但这是人们所能期望的最好结果。幸运的是，我们有时可以通过利用类型系统中可能存在的额外结构来做得更好。通常，不同的数据类型并非完全独立，并且可能存在一种类型对象可以被视为另一种类型对象的方式。这个过程称为强制转换。
通常，我们可以通过设计将一种类型的对象转换为另一种类型的等价对象的强制转换函数来实现这个想法。
这种强制转换方案与定义显式跨类型操作的方法相比有一些优势。尽管我们仍然需要编写强制转换函数来关联类型，但我们只需要为每对类型编写一个函数，而不是为每组类型和每个泛型操作编写不同的函数。我们在这里依赖的是类型之间的适当转换仅取决于类型本身，而不取决于要应用的具体操作。
强制转换的扩展带来了更多优势。一些更复杂的强制转换方案不仅尝试将一种类型强制转换为另一种类型，而且可能尝试将两种不同的类型强制转换为第三种共同类型。考虑一个菱形和一个矩形：两者都不是对方的特例，但都可以被视为四边形。强制转换的另一个扩展是迭代强制转换，其中一种数据类型通过中间类型强制转换为另一种类型。考虑整数可以通过首先将其转换为有理数，然后将该有理数转换为实数来转换为实数。以这种方式链接强制转换可以减少程序所需的总强制转换函数数量。
尽管有优势，但强制转换确实有潜在的缺点。首先，强制转换函数在应用时可能会丢失信息。在我们的示例中，有理数是精确表示，但当转换为复数时会变成近似值。
### 2.8 Efficiency
数据表示和处理方式的选择常常受到不同方案效率的影响。效率指的是表示或过程所消耗的计算资源，例如计算函数结果或表示对象所需的时间和内存量。这些数量因实现细节的不同可能会有很大差异。
#### 1. 测量效率
准确测量程序运行所需的时间或消耗的内存具有挑战性，因为这些结果取决于计算机配置的许多细节。更可靠地描述程序效率的方法是测量某些事件发生的次数，例如函数调用。
空间：要理解函数对空间的需求，我们必须在我们计算的环境模型中一般性地说明内存是如何使用、保存和回收的。在计算表达式时，解释器会保留所有活动环境以及这些环境引用的所有值和帧。如果环境为某个正在计算的表达式提供计算上下文，则该环境是活动的。当其第一帧被创建的函数调用最终返回时，环境变为非活动状态。
#### 2. 记忆化
树递归计算过程通常可以通过记忆化技术变得更为高效，这是一种提升重复计算的递归函数效率的强大方法。记忆化函数会存储之前接收到的任何参数的返回值。
记忆化可以自然地表达为一个高阶函数，也可以用作装饰器。下面的定义创建了一个先前计算结果的高速缓存，这些结果通过计算它们的参数进行索引。使用字典要求被记忆化函数的参数是不可变的。
```python
>>> def memo(f):
        cache = {}
        def memoized(n):
            if n not in cache:
                cache[n] = f(n)
            return cache[n]
        return memoized
```
#### 3. 增长阶
不同过程在消耗计算资源（空间和时间）的速率上可能存在巨大差异。然而，精确确定调用函数时将会使用多少空间或时间是一项非常困难的任务，这取决于许多因素。分析过程的一个有用方法是将其与一组具有相似需求的过程进行分类。一个有用的分类是过程的增长阶，它以简单的方式表达了过程的资源需求如何随着输入的函数而增长。
Θ符号：让n是衡量某个过程输入大小的参数，让R(n)是该过程对于大小为n的输入所需的某种资源量。在我们之前的例子中，我们将n视为要计算的给定函数的数值，但还有其他可能性。例如，如果我们的目标是计算一个数的平方根的近似值，我们可以将n视为所需的精度位数。R(n)可以衡量使用的内存量、执行的基本机器步骤数等。在每次只执行固定步骤数的计算机中，评估表达式所需的时间将与评估过程中执行的基本步骤数成正比。
我们说R(n)具有增长阶Θ(f(n))，写作R(n) = Θ(f(n))（发音为"theta of f(n)"），如果存在与n无关的正常数k₁和k₂，使得对于任何大于某个最小值m的n值，有：
```
k₁·f(n) ≤ R(n) ≤ k₂·f(n)
```
换句话说，对于大的n，值R(n)总是被夹在两个都随f(n)缩放的数值之间：
- 下界k₁·f(n)
- 上界k₂·f(n)

增长阶的设计目的是简化计算过程的分析和比较。许多不同的过程可以具有相同的增长阶，这表明它们以相似的方式扩展。知道并识别常见的增长阶以及识别相同增长阶的过程是计算机科学家的基本技能。
1. 常数项：常数项不影响过程的增长阶。因此，例如，Θ(n)和Θ(500·n)是相同的增长阶。这个性质来源于Θ符号的定义，它允许我们为上下界选择任意常数k₁和k₂（例如1/500）。为简单起见，常数总是从增长阶中省略。
2. 对数：对数的底数不影响过程的增长阶。例如，log₂n和log₁₀n是相同的增长阶。改变对数的底数相当于乘以一个常数因子。
3. 嵌套：当内部计算过程在外部过程的每一步重复时，整个过程增长阶是外部过程和内部过程步骤数的乘积。

低阶项：随着过程输入的增长，计算中增长最快的部分主导了使用的总资源。Θ符号捕捉了这种直觉。在求和中，除了增长最快的项外，所有项都可以删除而不改变增长阶。
常见类别：给定这些等价性质，一小组常见的类别出现来描述大多数计算过程。最常见的类别从增长最慢到最快列出如下，以及随着输入增加的增长描述。每个类别都有相应的例子。
|类别|Θ符号|增长描述|示例|
| :---: | :---: | :---: | :---: | 
|常数|Θ(1)|增长与输入无关|abs|
|对数|Θ(log n)|输入倍增时资源增加常数倍|fast_exp|
|线性|Θ(n)|输入增加时资源线性增加|exp|
|二次|Θ(n²)|输入增加时资源增加n倍|one_more|
|指数|Θ(bⁿ)|输入增加时资源指数倍增加|fib|

指数增长描述了许多不同的增长阶，因为改变底数b确实会影响增长阶。
### 2.9 Recursive Objects
对象可以将其他对象作为属性值。当一个类的对象具有同一类的对象作为属性值时，这就是一个递归对象。
#### 1. 链表
链表由第一个元素和链表的其余部分组成。链表的其余部分本身也是一个链表——这是一个递归定义。空链表是一种特殊情况，它没有第一个元素或其余部分。链表是一个序列：它具有有限长度并支持按索引选择元素。
我们现在可以实现一个具有相同行为的类。在这个版本中，我们将使用特殊方法名定义其行为，使我们的类能够与Python内置的len函数和元素选择运算符（方括号或operator.getitem）一起工作。这些内置函数会调用类的特殊方法名：长度通过__len__计算，元素选择通过__getitem__计算。空链表由一个空元组表示，其长度为0且没有元素
```python
>>> class Link:
        """一个具有第一个元素和其余部分的链表。"""
        empty = ()
        
        def __init__(self, first, rest=empty):
            assert rest is Link.empty or isinstance(rest, Link)
            self.first = first
            self.rest = rest
        
        def __getitem__(self, i):
            if i == 0:
                return self.first
            else:
                return self.rest[i-1]
        
        def __len__(self):
            return 1 + len(self.rest)

>>> s = Link(3, Link(4, Link(5)))
>>> len(s)
3
>>> s[1]
4
```
`__len__`和`__getitem__`的定义实际上是递归的。当应用于用户定义的对象参数时，内置Python函数len会调用名为`__len__`的方法。同样，元素选择运算符会调用名为`__getitem__`的方法。因此，这两个方法的主体会间接调用自己。对于`__len__`，当self.rest求值为空元组Link.empty时达到基本情况，其长度为0。
内置函数isinstance返回第一个参数的类型是否是第二个参数的类型或其子类。如果rest是Link实例或Link的某个子类的实例，则isinstance(rest, Link)为真。
我们的实现是完整的，但目前很难检查Link类的实例。为了帮助调试，我们还可以定义一个函数将Link转换为字符串表达式。
```python
>>> def link_expression(s):
        """返回将求值为s的字符串。"""
        if s.rest is Link.empty:
            rest = ''
        else:
            rest = ', ' + link_expression(s.rest)
        return 'Link({0}{1})'.format(s.first, rest)

>>> link_expression(s)
'Link(3, Link(4, Link(5)))'
```
这种显示Link的方式非常方便，我们希望每当显示Link实例时都使用它。我们可以通过将link_expression函数设置为特殊类属性__repr__的值来确保此行为。Python通过调用其__repr__方法来显示用户定义类的实例。
```python
>>> Link.__repr__ = link_expression
>>> s
Link(3, Link(4, Link(5)))
```
Link类具有闭包性质。就像列表的元素本身可以是列表一样，Link可以包含一个Link作为其第一个元素。
```python
>>> s_first = Link(s, Link(6))
>>> s_first
Link(Link(3, Link(4, Link(5))), Link(6))
```
s_first链表只有两个元素，但其第一个元素是一个包含三个元素的链表。
```python
>>> len(s_first)
2
>>> len(s_first[0])
3
>>> s_first[0][2]
5
```
递归函数特别适合操作链表。例如，递归函数extend_link构建一个链表，包含一个Link实例s的元素，后跟另一个Link实例t的元素。将此函数安装为Link类的__add__方法可以模拟内置列表的加法行为。
```python
>>> def extend_link(s, t):
        if s is Link.empty:
            return t
        else:
            return Link(s.first, extend_link(s.rest, t))

>>> extend_link(s, s)
Link
(3, Link(4, Link(5, Link(3, Link(4, Link(5))))))
>>> Link.__add__ = extend_link
>>> s + s
Link(3, Link(4, Link(5, Link(3, Link(4, Link(5))))))
```
与列表推导式不同，可以使用两个高阶函数从另一个链表生成链表：map_link和filter_link。下面定义的map_link函数对链表s的每个元素应用函数f，并构建一个包含结果的链表。
```python
>>> def map_link(f, s):
        if s is Link.empty:
            return s
        else:
            return Link(f(s.first), map_link(f, s.rest))
>>> map_link(square, s)
Link(9, Link(16, Link(25)))
```
filter_link函数返回一个链表，其中包含链表s中所有使f返回真值的元素。map_link和filter_link的组合可以表达与列表推导式相同的逻辑。
```python
>>> def filter_link(f, s):
        if s is Link.empty:
            return s
        else:
            filtered = filter_link(f, s.rest)
            if f(s.first):
                return Link(s.first, filtered)
            else:
                return filtered
>>> odd = lambda x: x % 2 == 1
>>> map_link(square, filter_link(odd, s))
Link(9, Link(25))
>>> [square(x) for x in [3, 4, 5] if odd(x)]
[9, 25]
```
join_link函数递归地构造一个字符串，其中包含由某个分隔符字符串分隔的链表的元素。结果比link_expression的输出要紧凑得多。
```python
>>> def join_link(s, separator):
        if s is Link.empty:
            return ""
        elif s.rest is Link.empty:
            return str(s.first)
        else:
            return str(s.first) + separator + join_link(s.rest, separator)
>>> join_link(s, ", ")
'3, 4, 5'
```
递归构造：在逐步构造序列时，链表特别有用，这种情况在递归计算中经常出现。
#### 2. 树
树也可以通过用户定义类的实例来表示，而不是内置序列类型的嵌套实例。树是任何具有属性为分支序列的数据结构，这些分支本身也是树。
内部值：之前我们定义了树，使得所有值都出现在树的叶节点上。通常也会定义在每个子树根节点处具有内部值的树。内部值在树中被称为标签。下面的Tree类表示这样的树，其中每棵树都有一个分支序列，这些分支本身也是树。
```python
>>> class Tree:
        def __init__(self, label, branches=()):
            self.label = label
            for branch in branches:
                assert isinstance(branch, Tree)
            self.branches = branches

        def __repr__(self):
            if self.branches:
                return 'Tree({0}, {1})'.format(self.label, repr(self.branches))
            else:
                return 'Tree({0})'.format(repr(self.label))
        
        def is_leaf(self):
            return not self.branches
```
#### 3. 集合
除了列表、元组和字典之外，Python还有第四种内置容器类型，称为集合。集合字面量遵循数学符号，元素用花括号括起来。重复元素在构造时被移除。集合是无序集合，因此打印的顺序可能与集合字面量中的元素顺序不同。
Python集合支持多种操作，包括成员测试、长度计算以及并集和交集的标准集合操作。
除了并集和交集，Python集合还支持其他几种方法。谓词isdisjoint、issubset和issuperset提供集合比较。集合是可变的，可以使用add、remove、discard和pop一次更改一个元素。其他方法提供多元素变更，例如clear和update。
实现集合：抽象地说，集合是一个不同对象的集合，支持成员测试、并集、交集和添加。添加元素和集合会返回一个新的集合，其中包含原始集合的所有元素以及新元素（如果它是不同的）。并集和交集分别返回出现在任一集合或两个集合中的元素集合。与任何数据抽象一样，我们可以在任何提供这种行为集合的集合表示上自由实现任何函数。
在本节的其余部分，我们将考虑三种不同的实现集合的方法，它们的表示方式各不相同。我们将通过分析集合操作的增长阶来表征这些不同表示方式的效率。我们将使用本节前面的Link和Tree类，它们为基本集合操作提供了简单而优雅的递归解决方案。
集合作为无序序列：表示集合的一种方式是作为没有元素出现超过一次的序列。空集由空序列表示。成员测试递归遍历列表。
```python
>>> def empty(s):
        return s is Link.empty

>>> def set_contains(s, v):
        """当且仅当集合s包含v时返回True。"""
        if empty(s):
            return False
        elif s.first == v:
            return True
        else:
            return set_contains(s.rest, v)

>>> s = Link(4, Link(1, Link(5)))
>>> set_contains(s, 2)
False
>>> set_contains(s, 5)
True
```
这个set_contains的实现平均需要Θ(n)时间来测试元素成员资格，其中n是集合s的大小。使用这个线性时间函数进行成员资格测试，我们也可以在线性时间内向集合中添加一个元素。
```python
>>> def adjoin_set(s, v):
        """返回包含s的所有元素和元素v的集合。"""
        if set_contains(s, v):
            return s
        else:
            return Link(v, s)

>>> t = adjoin_set(s, 2)
>>> t
Link(2, Link(4, Link(1, Link(5))))
```
在设计表示方式时，我们应该关注的问题之一是效率。求两个集合set1和set2的交集也需要成员资格测试，但这次必须测试set1的每个元素是否在set2中，导致步骤数呈二次增长阶Θ(n²)，其中两个集合的大小均为n。
```python
>>> def intersect_set(set1, set2):
        """返回包含set1和set2共有元素的集合。"""
        return keep_if_link(set1, lambda v: set_contains(set2, v))

>>> intersect_set(t, apply_to_all_link(s, square))
Link(4, Link(1))
```
当计算两个集合的并集时，我们必须小心不要包含任何元素两次。union_set函数也需要线性次数的成员资格测试，创建一个也包含Θ(n²)步骤的过程。
```python
>>> def union_set(set1, set2):
        """返回包含set1或set2中所有元素的集合。"""
        set1_not_set2 = keep_if_link(set1, lambda v: not set_contains(set2, v))
        return extend_link(set1_not_set2, set2)

>>> union_set(t, s)
Link(2, Link(4, Link(1, Link(5))))
```
1. 集合作为有序序列：

加速集合操作的一种方法是改变表示方式，使集合元素按递增顺序列出。为此，我们需要某种方法来比较两个对象，以便确定哪个更大。在Python中，许多不同类型的对象可以使用<和>运算符进行比较，但在这个例子中我们将专注于数字。我们将通过以递增顺序列出其元素来表示一组数字。
排序的一个优势体现在set_contains中：在检查对象是否存在时，我们不再需要扫描整个集合。如果我们遇到一个大于我们要查找的项的集合元素，那么我们知道该项不在集合中：
```python
>>> def set_contains(s, v):
        if empty(s) or s.first > v:
            return False
        elif s.first == v:
            return True
        else:
            return set_contains(s.rest, v)

>>> u = Link(1, Link(4, Link(5)))
>>> set_contains(u, 0)
False
>>> set_contains(u, 4)
True
```
这节省了多少步骤？在最坏的情况下，我们要查找的项可能是集合中最大的一个，因此步骤数与无序表示相同。另一方面，如果我们搜索许多不同大小的项，我们可以预期有时我们能够在列表开始附近停止搜索，而其他时候我们仍然需要检查大部分列表。平均而言，我们应该预期需要检查集合中大约一半的项。因此，所需的平均步骤数约为n/2。这仍然是Θ(n)增长，但确实在实践中比之前的实现节省了一些时间。
通过重新实现intersect_set，我们可以获得更显著的加速。在无序表示中，此操作需要Θ(n²)步，因为我们对set1的每个元素执行了set2的完整扫描。但使用有序表示，我们可以使用更聪明的方法。我们同时遍历两个集合，跟踪set1中的元素e1和set2中的元素e2。当e1和e2相等时，我们将该元素包含在交集中。
然而，假设e1小于e2。由于e2小于set2的剩余元素，我们可以立即得出结论e1不可能出现在set2的剩余部分中的任何地方，因此不在交集中。因此，我们不再需要考虑e1；我们丢弃它并继续处理set1的下一个元素。类似的逻辑在e2 < e1时推进set2的元素。以下是该函数：
```python
>>> def intersect_set(set1, set2):
        if empty(set1) or empty(set2):
            return Link.empty
        else:
            e1, e2 = set1.first, set2.first
            if e1 == e2:
                return Link(e1, intersect_set(set1.rest, set2.rest))
            elif e1 < e2:
                return intersect_set(set1.rest, set2)
            elif e2 < e1:
                return intersect_set(set1, set2.rest)

>>> intersect_set(s, s.rest)
Link(4, Link(5))
```
要估计此过程所需的步骤数，请观察在每个步骤中我们至少缩小一个集合的大小。因此，所需的步骤数最多为set1和set2的大小之和，而不是像无序表示那样的大小的乘积。这是Θ(n)增长而不是Θ(n²)——这是一个相当大的加速，即使对于中等大小的集合也是如此。例如，两个大小为100的集合的交集将需要大约200步，而不是无序表示的10,000步。
表示为有序序列的集合的添加和并集也可以在线性时间内计算

2. 集合作为二叉搜索树：

我们可以通过将集合元素排列成具有两个分支的树的形式，做得比有序列表表示更好。树的根节点包含集合的一个元素。左分支中的条目包括所有小于根节点元素的元素。右分支中的条目包括所有大于根节点元素的元素。下图显示了一些表示集合{1, 3, 5, 7, 9, 11}的树。同一集合可以用许多不同的树表示。在所有二叉搜索树中，左分支中的所有元素必须小于根节点的条目，右子树中的所有元素必须更大。
树表示的优点是：假设我们想检查一个值v是否包含在一个集合中。我们首先比较v与条目。如果v小于这个，我们知道只需要搜索左子树；如果v更大，只需要搜索右子树。现在，如果树是"平衡的"，每个子树将大约是原始树大小的一半。因此，在一个步骤中，我们将搜索大小为n的树的问题简化为搜索大小为n/2的树。由于树的大小每一步减半，我们应该预期搜索树所需的步骤数增长为Θ(log n)。对于大集合，这将比之前的表示有显著的加速。这个set_contains函数利用了树结构集合的排序结构。
```python
>>> def set_contains(s, v):
        if s is None:
            return False
        elif s.entry == v:
            return True
        elif s.entry < v:
            return set_contains(s.right, v)
        elif s.entry > v:
            return set_contains(s.left, v)
```
向集合中添加项的实现类似，也需要Θ(log n)步。要添加一个值v，我们比较v与条目以确定v应该添加到右分支还是左分支，并将新构造的分支与原始条目和其他分支拼接在一起。如果v等于条目，我们只返回节点。如果要求将v添加到空树，我们生成一个以v为条目且左右分支为空的Tree。以下是该函数：
```python
>>> def adjoin_set(s, v):
        if s is None:
            return Tree(v)
        elif s.entry == v:
            return s
        elif s.entry < v:
            return Tree(s.entry, s.left, adjoin_set(s.right, v))
        elif s.entry > v:
            return Tree(s.entry, adjoin_set(s.left, v), s.right)

>>> adjoin_set(adjoin_set(adjoin_set(None, 2), 3), 1)
Tree(2, Tree(1), Tree(3))
```
我们关于搜索树可以在对数步数内完成的声明基于树是"平衡的"假设，即每棵树的左子树和右子树具有大致相同数量的元素，因此每个子树包含其父树大约一半的元素。但我们如何确定我们构造的树将是平衡的？即使我们从一个平衡树开始，使用adjoin_set添加元素可能会产生不平衡的结果。由于新添加元素的位置取决于该元素与集合中已有项目的比较方式，我们可以预期如果我们"随机"添加元素，树将倾向于平均平衡。
但这并不是保证。例如，如果我们从一个空集开始，并按顺序添加数字1到7，我们最终会得到一个高度不平衡的树，其中所有左子树都为空，因此它没有比简单有序列表更好的优势。解决这个问题的一种方法是定义一个操作，将任意树转换为具有相同元素的平衡树。我们可以在每次adjoin_set操作后执行此转换以保持集合的平衡。
交集和并集操作可以通过将树结构集合转换为有序列表再转回来在线性时间内执行。
Python集合实现：Python内置的set类型在内部不使用这些表示中的任何一种。相反，Python使用一种基于称为哈希技术的表示，该技术提供恒定时间的成员资格测试和添加操作。内置的Python集合不能包含可变数据类型，例如列表、字典或其他集合。为了允许嵌套集合，Python还包括一个内置的不可变frozenset类，它与set类共享方法，但排除了可变方法和运算符。
___
[返回目录](#目录)
___
## Chapter 3: Interpreting Computer Programs<a id = "chapter3"></a>
### 3.1 Introduction
第 1 章和第 2 章阐述了编程中两个基本要素——函数与数据之间的紧密联系。
本章聚焦于编程的第三个基本要素：程序本身。Python 程序本质上只是文本的集合。只有通过解释过程，我们才能基于这些文本执行有意义的计算。像 Python 这样的编程语言之所以有用，是因为我们可以定义一个解释器——一个执行 Python 求值与执行过程的程序。可以毫不夸张地说，这是编程中最根本的思想：解释器（它决定了编程语言中表达式的含义）本身也只是一个程序。
编程语言在语法结构、特性和应用领域上差异巨大。在通用编程语言中，函数定义和函数应用是普遍存在的结构。另一方面，也存在一些功能强大但不包含对象系统、高阶函数、赋值，甚至 while 和 for 等控制结构的语言。作为特性极简但功能强大的语言示例，我们将介绍 Scheme 编程语言。本书介绍的 Scheme 子集甚至完全不允许可变值。
本章我们将研究解释器的设计及其执行程序时创建的计算过程。为一个通用编程语言设计解释器，这一前景可能看似令人生畏。毕竟，解释器是能够根据输入执行任何可能计算的程序。然而，许多解释器具有一种优雅的共通结构：两个相互递归的函数。第一个函数在环境中求值表达式；第二个函数将函数应用于参数。
这两个函数之所以是递归的，是因为它们的定义相互依赖：应用函数需要对其函数体中的表达式进行求值，而对表达式求值可能涉及应用一个或多个函数。
### 3.2 Functional Programming
#### 1. 机器语言与高级语言
在现代计算机上运行的软件是用多种编程语言编写的。 存在物理语言，例如特定计算机的机器语言。这些语言关注如何以存储位和基本机器指令的形式来表示数据和控制。机器语言程序员关心的是利用给定的硬件来构建系统和工具，以便高效地实现资源有限的计算。
高级语言建立在机器语言的底层之上，它隐藏了对数据如何以位集合形式表示，以及程序如何以基本指令序列形式表示的关注。这些语言拥有适用于软件系统大规模组织的组合与抽象手段，例如函数定义。
本章我们将介绍一种鼓励函数式风格的高级编程语言。我们的研究对象——Scheme 语言的一个子集——采用与 Python 非常相似的计算模型，但它只使用表达式（没有语句），专长于符号计算，并且只使用不可变值。
Scheme 是 Lisp 语言的一种方言。Lisp 是至今仍广泛使用的第二古老的编程语言（仅次于 Fortran）。
#### 2. Scheme表达式
Scheme 程序由表达式构成，表达式分为调用表达式和特殊形式两类。调用表达式由一个操作符表达式和零个或多个操作数子表达式组成，这与 Python 类似。操作符和操作数都包含在圆括号内
Scheme 完全使用前缀表示法。操作符通常是符号，如 + 和 *。调用表达式可以嵌套，并且可以跨越多行
与 Python 类似，Scheme 表达式可以是基本表达式或组合表达式。数字字面量是基本表达式，而调用表达式是包含任意子表达式的组合形式。调用表达式的求值过程与 Python 一致：首先对操作符和操作数表达式求值，然后将作为操作符值的函数应用到作为操作数值的参数上。
Scheme 中的 if 表达式是一种特殊形式，这意味着虽然语法上它看起来像调用表达式，但具有不同的求值过程。if 表达式的一般形式为：
```scheme
(if <predicate> <consequent> <alternative>)
```
解释器求值 if 表达式时，首先对表达式的`<predicate>`部分求值。如果`<predicate>`求值为真值，解释器则对`<consequent>`求值并返回其值；否则对`<alternative>`求值并返回其值。
数值可以使用常见的比较运算符进行比较，但同样采用前缀表示法
Scheme 的布尔值 #t（或 true）和 #f（或 false）可以与布尔特殊形式结合使用，这些特殊形式的求值过程与 Python 类似：
- (and `<e1>` ... `<en>`)：解释器按从左到右的顺序依次对表达式`<e>`求值。如果任意`<e>`求值为假，则 and 表达式的值为假，且后续的`<e>`不再求值。如果所有`<e>`都求值为真，则 and 表达式的值为最后一个`<e>`的值。
- (or `<e1>` ... `<en>`)：解释器按从左到右的顺序依次对表达式`<e>`求值。如果任意`<e>`求值为真，则将该值作为 or 表达式的值返回，且后续的`<e>`不再求值。如果所有`<e>`都求值为假，则 or 表达式的值为假。
- (not `<e>`)：当表达式`<e>`求值为假时，not 表达式的值为真；否则为假。
#### 3. 定义
值可以通过 define 特殊形式进行命名
新的函数（在 Scheme 中称为过程） 可以通过第二种版本的 define 特殊形式来定义。
过程定义的一般形式为：
```scheme
(define (<name> <formal parameters>) <body>)
```
`<name>`是一个符号，用于在环境中关联该过程定义。`<formal parameters>`是在过程主体中用于指代相应实参的名称。`<body>`是一个表达式，当形式参数被过程应用的实际参数替换时，该表达式将产生过程应用的值。`<name>`和`<formal parameters>`被一同括在圆括号内，正如在实际调用被定义过程时那样。
定义过程后，我们现在可以在调用表达式中使用它：
用户定义的函数可以接受多个参数，并包含特殊形式
Scheme 支持局部定义，其词法作用域规则与 Python 相同。
匿名函数通过 lambda 特殊形式创建。lambda 的用法与 define 创建过程的方式相同，只是不为过程指定名称：
```scheme
(lambda (<formal-parameters>) <body>)
```
这样得到的过程与使用 define 创建的过程完全一样。唯一的区别是它没有在环境中与任何名称关联
与任何以过程为值的表达式一样，lambda 表达式可以用作调用表达式中的操作符
#### 4. 序对
序对是 Scheme 语言的内置结构。由于历史原因，序对通过内置函数 cons 创建，并通过 car 和 cdr 访问其元素
递归列表也通过序对内置在语言中。用特殊值 nil 或 '() 表示空列表。递归列表值通过将其元素置于圆括号内、以空格分隔的形式呈现：
可以使用基本谓词 null? 来判断列表是否为空。
#### 5. 引用
迄今为止我们使用的所有复合数据对象最终都是由数字构成的。Scheme 的一大优势在于能够将任意符号作为数据处理。
为了操作符号，我们需要在语言中引入一个新要素：引用数据对象的能力。假设我们想要构建列表 (a b)，我们不能直接用 (list a b) 实现，因为这个表达式构建的是 a 和 b 的值组成的列表，而不是符号本身。在 Scheme 中，我们可以通过在符号前加上单引号来指代符号 a 和 b 本身，而不是它们的值
在 Scheme 中，任何不被求值的表达式都称为被引用的。
引用允许我们谈论语言本身，Scheme 也是如此
引用还允许我们使用列表的常规打印表示法来输入复合对象
### 3.3 Exceptions
程序员必须时刻警惕程序中可能出现的错误。这样的例子比比皆是：函数可能接收到非预期的参数、必要资源可能缺失、网络连接可能中断。在设计程序时，必须预见可能出现的异常情况，并采取适当措施加以处理。
处理程序错误没有单一的正确方法。设计用于提供持久服务（如网络服务器）的程序应该对错误具有鲁棒性——记录错误供后续分析，同时尽可能继续处理新请求。另一方面，Python解释器通过立即终止并打印错误信息来处理错误，以便程序员能及时解决问题。无论如何，程序员必须有意识地选择他们的程序应如何响应异常情况。
异常（本节的主题）为程序添加错误处理逻辑提供了一种通用机制。引发异常是一种中断程序正常执行流程的技术，它标志着某种异常情况已发生，并直接返回到程序中预定义的处理该情况的代码块。每当Python解释器检测到表达式或语句中的错误时，就会引发异常。用户也可以通过raise和assert语句主动引发异常。
引发异常。异常是一个对象实例，其类直接或间接继承自BaseException类。第1章介绍的assert语句会引发AssertionError类的异常。通常，任何异常实例都可以通过raise语句引发。raise语句的一般形式在Python文档中有描述。最常见的用法是构造异常实例并引发它
```python
>>> raise Exception('An error occurred')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
Exception: an error occurred
```
当异常被引发时，当前代码块中后续的语句都不会执行。除非异常被处理（下文将描述），否则解释器将直接返回到交互式的读取-求值-打印循环，或者如果Python是通过文件参数启动的，则完全终止。此外，解释器会打印堆栈回溯——这是一种结构化的文本块，描述了引发异常的执行分支中嵌套的活动函数调用集合。在上面的例子中，文件名`<stdin>`表示该异常是由用户在交互式会话中引发的，而不是来自文件中的代码。
处理异常。异常可以通过外层的try语句处理。try语句由多个子句组成：第一个以try开始，其余以except开始：
```python
try:
    <try suite>
except <exception class> as <name>:
    <except suite>
...
```
执行try语句时，`<try suite>`总是立即执行。仅当在执行`<try suite>`过程中引发异常时，才会执行except子句的代码块。每个except子句指定要处理的特定异常类。例如，如果`<exception class>`是AssertionError，那么在执行`<try suite>`过程中引发的任何继承自AssertionError的类的实例都将由后续的`<except suite>`处理。在`<except suite>`中，标识符`<name>`被绑定到引发的异常对象，但这种绑定不会超出`<except suite>`的范围。
try语句会处理在`<try suite>`中（直接或间接）应用的函数体内发生的异常。当异常被引发时，控制流直接跳转到最近的处理该类型异常的try语句的`<except suite>`体
异常对象本身可以具有属性，例如assert语句中声明的错误信息，以及关于异常在何处引发的执行信息。用户定义的异常类可以有额外的属性。
异常是另一种帮助我们将程序关注点分离到模块化部分的技术。在这个例子中，Python的异常机制使我们能够将迭代改进的逻辑（出现在try子句的代码块中，保持不变）与错误处理的逻辑（出现在except子句中）分离开来。我们还将发现，在用Python实现解释器时，异常是一个非常有用的特性。
### 3.4 Interpreters for Languages with Combination
现在我们开始探索一门关键技术——如何通过其他语言来定义新的语言。元语言抽象（即建立新的语言）在所有工程设计分支中都扮演着重要角色。这对计算机编程尤为重要，因为在编程中我们不仅能构思新语言，还能通过构建解释器来实现这些语言。编程语言的解释器本质上是一个函数：当应用于该语言的表达式时，它会执行求值该表达式所需的所有操作。
我们将首先为 Scheme 语言的一个受限子集（称为 Calculator）定义解释器。随后，我们将逐步勾勒出完整 Scheme 语言解释器的框架。我们构建的解释器将是完备的——这意味着我们可以用它来编写完全通用的 Scheme 程序。为此，它将实现我们在第 1 章中为 Python 程序介绍的环境模型求值机制。
#### 1. Scheme语法计算器
Scheme语法计算器（简称计算器）是一种支持加、减、乘、除算术运算的表达式语言。计算器沿用了Scheme的调用表达式语法和操作符行为。加法（+）和乘法（*）运算均可接受任意数量的参数
减法（-）具有两种行为模式：当只有一个参数时，对参数取负；当至少有两个参数时，用第一个参数减去后续所有参数。除法（/）也有两种类似行为：计算单个参数的乘法逆元，或用第一个参数除以后续所有参数
调用表达式的求值过程是：先对操作数子表达式求值，再将操作符应用于求值结果
我们将用Python实现计算器语言的解释器。这意味着我们将编写一个Python程序，它接受字符串行作为输入，并将这些行作为计算器表达式求值后返回结果。如果计算器表达式格式不正确，我们的解释器将抛出相应的异常。
#### 2. 表达式树
到目前为止，表达式树一直是我们描述求值过程中所引用的概念实体；我们从未在程序中显式地将表达式树表示为数据。为了编写解释器，我们必须将表达式作为数据来操作。
在计算器中，基本表达式就是一个数字或字符串：可以是int、float或操作符符号。所有组合表达式都是调用表达式。调用表达式是一个Scheme列表，其第一个元素是操作符，后面跟着零个或多个操作数表达式。
Scheme序对。在Scheme中，列表是嵌套的序对，但并非所有序对都是列表。为了在Python中表示Scheme序对和列表，我们将定义一个Pair类，类似于本章前面提到的Rlist类。其实现可见于scheme_reader。
空列表由一个名为nil的对象表示，它是nil类的一个实例。我们假设只会创建一个nil实例。
Pair类和nil对象是在Python中表示的Scheme值。它们具有repr字符串（即Python表达式）和str字符串（即Scheme表达式）。
```python
>>> s = Pair(1, Pair(2, nil))
>>>s
Pair(1, Pair(2, nil))
>>> print(s)
(1 2)
```
它们实现了基本的Python序列接口（包括长度和元素选择），以及返回Scheme列表的map方法。
```python
>>> len(s)
2
>>> s[1]
2
>>> print(s.map(lambda x: x+4))
(5 6)
```
嵌套列表。嵌套的序对可以表示列表，但列表的元素本身也可以是列表。因此，序对足以表示Scheme表达式，这些表达式实际上就是嵌套的列表。
```python
>>> expr = Pair('+', Pair(Pair('*', Pair(3, Pair(4, nil))), Pair(5, nil)))
>>> print(expr)
(+ (* 3 4) 5)
>>> print(expr.second.first)
(* 3 4)
>>> expr.second.first.second.first
3
```
这个例子表明，所有计算器表达式都是嵌套的Scheme列表。我们的计算器解释器将读取嵌套的Scheme列表，将其转换为表示为嵌套Pair实例的表达式树（下文将介绍“解析表达式”），然后对表达式树求值以产生结果（下文将介绍“计算器求值”）。
#### 3. 解析表达式
解析是从原始文本输入生成表达式树的过程。解析器由两个组件构成：词法分析器和语法分析器。首先，词法分析器将输入字符串分割成词法单元——这些是语言的最小语法单位，如名称和符号。其次，语法分析器根据这个词法单元序列构建表达式树。词法分析器产生的词法单元序列会被语法分析器消耗。
词法分析。将字符串解释为词法单元序列的组件称为词法分析器。在我们的实现中，词法分析器是 scheme_tokens 中名为 tokenize_line 的函数。Scheme 词法单元由空白符、圆括号、点或单引号分隔。分隔符本身就是词法单元，符号和数字也是如此。词法分析器逐字符分析一行文本，验证符号和数字的格式。
对结构良好的计算器表达式进行词法分析，会分离出所有符号和分隔符，但会将多字符数字（如 2.3）识别出来并转换为数值类型
```python
>>> tokenize_line('(+ 1 (* 2.3 45))')
['(', '+', 1, '(', '*', 2.3, 45, ')', ')']
```
词法分析是一个迭代过程，可以独立应用于输入程序的每一行。
语法分析。将词法单元序列解释为表达式树的组件称为语法分析器。语法分析是一个树形递归过程，必须考虑可能跨越多行的整个表达式。
语法分析由 scheme_reader 中的 scheme_read 函数实现。之所以是树形递归，是因为分析词法单元序列通常涉及将其中某个子序列分析成子表达式，而该子表达式本身又充当更大表达式树（例如操作数）的一个分支。递归生成了求值器所需的层次结构。
scheme_read 函数期望其输入 src 是一个 Buffer 实例，该实例提供对词法单元序列的访问。定义在 buffer 模块中的 Buffer 类，将跨越多行的词法单元收集到单个对象中，以便进行语法分析：
```python
>>> lines = ['(+ 1', '   (* 2.3 45))']
>>> expression = scheme_read(Buffer(tokenize_lines(lines)))
>>> expression
Pair('+', Pair(1, Pair(Pair('*', Pair(2.3, Pair(45, nil))), nil)))
>>> print(expression)
(+ 1 (* 2.3 45))
```
scheme_read 函数首先检查各种基本情况，包括空输入（会引发文件结束异常，在 Python 中称为 EOFError）和基本表达式。每当遇到`(`词法单元（表示列表开始）时，就会递归调用 read_tail。
read_tail 函数继续从同一个输入 src 读取，但期望在列表开始后被调用。其基本情况是空输入（错误）或表示列表结束的右括号。它的递归调用过程是：先用 scheme_read 读取列表的第一个元素，然后用 read_tail 读取列表的其余部分，最后返回一个以 Pair 表示的列表。
这个 scheme_read 的实现可以读取结构良好的 Scheme 列表，而这正是计算器语言所需的全部功能。解析点对列表和引用形式留作练习。
具有信息性的语法错误能显著提高解释器的可用性。引发的 SyntaxError 异常包含对所遇问题的描述
#### 4. 计算器求值
scalc 模块实现了计算器语言的求值器。calc_eval 函数接收一个表达式作为参数并返回其值。辅助函数 simplify、reduce 和 as_scheme_list 的定义位于模型中，并在下文使用。
对于计算器语言，合法的表达式语法形式只有两种：数字和调用表达式（即表示结构良好的 Scheme 列表的 Pair 实例）。数字是自求值的；它们可以直接从 calc_eval 返回。调用表达式则需要函数应用。
```python
>>> def calc_eval(exp):
        """求值一个计算器表达式。"""
        if type(exp) in (int, float):
            return simplify(exp)
        elif isinstance(exp, Pair):
            arguments = exp.second.map(calc_eval)
            return simplify(calc_apply(exp.first, arguments))
        else:
            raise TypeError(exp + ' 不是数字或调用表达式')
```
调用表达式的求值过程是：首先将 calc_eval 函数递归地映射到操作数列表上，从而计算出参数列表；然后，在第二个函数 calc_apply 中将操作符应用于这些参数。
计算器语言足够简单，我们可以在单个函数体内轻松表达应用每个操作符的逻辑。在 calc_apply 中，每个条件子句对应一个操作符的应用。
```python
>>> def calc_apply(operator, args):
        """将指定的操作符应用于参数列表。"""
        if not isinstance(operator, str):
            raise TypeError(str(operator) + ' 不是符号')
        if operator == '+':
            return reduce(add, args, 0)
        elif operator == '-':
            if len(args) == 0:
                raise TypeError(operator + ' 至少需要 1 个参数')
            elif len(args) == 1:
                return -args.first
            else:
                return reduce(sub, args.second, args.first)
        elif operator == '*':
            return reduce(mul, args, 1)
        elif operator == '/':
            if len(args) == 0:
                raise TypeError(operator + ' 至少需要 1 个参数')
            elif len(args) == 1:
                return 1/args.first
            else:
                return reduce(truediv, args.second, args.first)
        else:
            raise TypeError(operator + ' 是未知操作符')
```
以上代码中，每个子句计算不同操作符的结果，或在参数数量错误时引发适当的 TypeError。calc_apply函数可以直接调用，但必须传递一个值列表作为参数，而不是操作数表达式列表。
```python
>>> calc_apply('+', as_scheme_list(1, 2, 3))
6
>>> calc_apply('-', as_scheme_list(10, 1, 2, 3))
4
>>> calc_apply('*', nil)
1
>>> calc_apply('*', as_scheme_list(1, 2, 3, 4, 5))
120
>>> calc_apply('/', as_scheme_list(40, 5))
8.0
```
calc_eval 的作用是通过先计算操作数子表达式的值，再将它们作为参数传递给 calc_apply，从而正确地调用 calc_apply。因此，calc_eval 可以接受嵌套表达式。
```python
>>> print(exp)
(+ (* 3 4) 5)
>>> calc_eval(exp)
17
```
calc_eval 的结构是基于类型（表达式的形式）进行分发的典型示例。第一种表达式形式是数字，它不需要额外的求值步骤。通常，不需要额外求值步骤的基本表达式称为自求值表达式。在我们的计算器语言中，唯一的自求值表达式是数字，但通用编程语言可能还包括字符串、布尔值等。
读取-求值-打印循环。与解释器交互的典型方式是通过读取-求值-打印循环（REPL），这是一种读取表达式、求值并打印结果给用户的交互模式。Python 交互式会话就是这种循环的一个例子。
REPL 的实现可以在很大程度上独立于其使用的解释器。下面的 read_eval_print_loop 函数从用户处缓冲输入，使用特定于语言的 scheme_read 函数构建表达式，然后打印对该表达式应用 calc_eval 的结果。
```python
>>> def read_eval_print_loop():
        """运行计算器的读取-求值-打印循环。"""
        while True:
            src = buffer_input()
            while src.more_on_line:
                expression = scheme_read(src)
                print(calc_eval(expression))
```
这个版本的 read_eval_print_loop 包含了交互界面的所有基本组件。
这个循环实现没有提供终止或错误处理机制。我们可以通过向用户报告错误来改进界面。同时，我们允许用户通过发出键盘中断信号（UNIX 上是 Control-C）或文件结束异常（UNIX 上是 Control-D）来退出循环。为了实现这些改进，我们将 while 语句的原始代码块放在 try 语句中。第一个 except 子句处理由 scheme_read 引发的 SyntaxError 和 ValueError 异常，以及由 calc_eval 引发的 TypeError 和 ZeroDivisionError 异常。
```python
>>> def read_eval_print_loop():
        """运行计算器的读取-求值-打印循环。"""
        while True:
            try:
                src = buffer_input()
                while src.more_on_line:
                    expression = scheme_read(src)
                    print(calc_eval(expression))
            except (SyntaxError, TypeError, ValueError, ZeroDivisionError) as err:
                print(type(err).__name__ + ':', err)
            except (KeyboardInterrupt, EOFError):  # <Control>-D 等。
                print('计算完成。')
                return
```
这个循环实现在报告错误时不会退出循环。与在出错时退出程序不同，在错误信息后重新启动循环允许用户修改他们的表达式。导入 readline 模块后，用户甚至可以使用上箭头或 Control-P 来回忆之前的输入。最终结果提供了一个信息丰富的错误报告界面
当我们把解释器泛化到计算器之外的新语言时，我们会看到 read_eval_print_loop 是通过一个解析函数、一个求值函数以及 try 语句处理的异常类型来参数化的。除了这些变化，所有 REPL 都可以使用相同的结构来实现。
### 3.5 Interpreters for Languages with Abstraction
计算器语言通过嵌套的调用表达式提供了组合手段。然而，它无法定义新的操作符、为值命名或表达通用的计算方法。计算器不支持任何形式的抽象。因此，它并非一门特别强大或通用的编程语言。现在，我们将转向定义一门通用编程语言的任务，该语言通过将名称绑定到值以及定义新操作来支持抽象。
与上一节以Python源代码形式呈现完整解释器不同，本节采用描述性方法。配套项目要求你通过构建一个功能完整的Scheme解释器来实现这里提出的思想。
#### 1. 结构
本节描述了Scheme解释器的总体结构。完成配套项目将产生此处所述解释器的一个可工作实现。
Scheme的解释器可以与计算器解释器共享许多相同结构。解析器产生一个表达式，由求值器进行解释。求值函数检查表达式的形式，对于调用表达式，它调用一个函数将过程应用于某些参数。求值器之间的主要差异在于特殊形式、用户定义函数以及计算的环境模型的实现。
解析。来自计算器解释器的scheme_reader和scheme_tokens模块几乎足以解析任何有效的Scheme表达式。然而，它尚不支持引用或点对列表。一个完整的Scheme解释器应该能够解析以下输入表达式：
```python
>>> read_line("(car '(1 . 2))")
Pair('car', Pair(Pair('quote', Pair(Pair(1, 2), nil)), nil))
```
你在实现Scheme解释器时的第一个任务，将是扩展scheme_reader以正确解析点对列表和引用。
求值。Scheme每次求值一个表达式。求值器的骨架实现定义在配套项目的scheme.py中。从scheme_read返回的每个表达式都被传递给scheme_eval函数，该函数在当前环境env中求值表达式expr。
scheme_eval函数求值Scheme中不同形式的表达式：基本表达式、特殊形式和调用表达式。Scheme中组合表达式的形式可以通过检查其第一个元素来确定。每个特殊形式都有自己的求值规则。下面是一个简化版的scheme_eval实现。为了聚焦我们的讨论，省略了一些错误检查和特殊形式处理。完整实现见配套项目。
```python
>>> def scheme_eval(expr, env):
        """在环境env中求值Scheme表达式expr。"""
        if scheme_symbolp(expr):
            return env[expr]
        elif scheme_atomp(expr):
            return expr
        first, rest = expr.first, expr.second
        if first == "lambda":
            return do_lambda_form(rest, env)
        elif first == "define":
            do_define_form(rest, env)
            return None
        else:
            procedure = scheme_eval(first, env)
            args = rest.map(lambda operand: scheme_eval(operand, env))
            return scheme_apply(procedure, args, env)
```
过程应用。上述的最后一个case会启动第二个过程——过程应用，由scheme_apply函数实现。Scheme中的过程应用过程比计算器中的calc_apply函数要通用得多。它处理两种参数：PrimitiveProcedure（原始过程）或LambdaProcedure（Lambda过程）。PrimitiveProcedure在Python中实现；它有一个实例属性fn，绑定到一个Python函数。此外，它可能（也可能不）需要访问当前环境。每当该过程被应用时，就会调用这个Python函数。
LambdaProcedure在Scheme中实现。它有一个body属性，是一个Scheme表达式，每当该过程被应用时，都会对这个表达式进行求值。要将该过程应用于参数列表，需要在新的环境中对body表达式进行求值。为了构建这个环境，需要在环境中添加一个新的帧，将过程的形式参数绑定到实际参数。然后使用scheme_eval对body进行求值。
求值/应用递归。实现求值过程的函数scheme_eval和scheme_apply是相互递归的。每当遇到调用表达式时，求值需要应用。应用则使用求值来将操作数表达式求值为参数，同时也对用户定义过程的主体进行求值。这种相互递归过程的一般结构在解释器中非常普遍：求值根据应用来定义，而应用根据求值来定义。
这个递归循环以语言原语结束。求值有一个基本情况，即求值一个基本表达式。某些特殊形式也构成没有递归调用的基本情况。函数应用有一个基本情况，即应用一个原始过程。这种相互递归的结构——一个处理表达式形式的eval函数和一个处理函数及其参数的apply函数——构成了求值过程的本质。
#### 2. 环境
至此，我们已经描述了 Scheme 解释器的结构，接下来将实现构成环境的 Frame 类。 每个 Frame 实例代表一个环境，其中符号绑定到值。一个帧包含一个绑定字典，以及一个父帧（全局帧的父帧为 None）。
绑定不是直接访问的，而是通过 Frame 的两个方法：lookup 和 define。lookup 实现了第 1 章所述的计算环境模型中的查找过程：先在当前帧的绑定中匹配符号；如果找到，则返回其绑定的值；如果未找到，则继续在父帧中查找。另一方面，define 方法则始终将符号绑定到当前帧中的某个值。
#### 3. 数据作为程序
在思考一个求值 Scheme 表达式的程序时，一个类比可能会有所帮助。关于程序含义的一种操作性观点是：程序是对抽象机器的描述。
我们的 Scheme 解释器被视为一台通用机器。当其他机器被描述为 Scheme 程序时，它能够模拟这些机器。它充当了编程语言所操作的数据对象与编程语言本身之间的桥梁。想象一下，用户向正在运行的 Scheme 解释器输入一个 Scheme 表达式。从用户的视角来看，像 (+ 2 2) 这样的输入表达式是编程语言中的一个表达式，解释器应该对其求值。然而，从 Scheme 解释器的视角来看，该表达式仅仅是一个由单词组成的句子，需要按照一组明确定义的规则进行处理。
用户的程序是解释器的数据——这一点不必引起混淆。事实上，有时忽略这种区别反而更加方便，并且可以让用户能够显式地将数据对象作为表达式求值。在 Scheme 中，我们每当使用 run 过程时，就会利用这一特性。Python 中也存在类似的函数：eval 函数会对 Python 表达式求值，而 exec 函数会执行 Python 语句。
对作为执行一部分而构建的表达式进行求值，是动态编程语言中一个常见且强大的特性。虽然很少有语言像 Scheme 那样普遍采用这种做法，但在程序执行过程中构建并求值表达式的能力，对任何程序员来说都可能是一个宝贵的工具。
___
[返回目录](#目录)
___
## Chapter 4: Data Processing<a id = "chapter4"></a>
### 4.1 Introduction
现代计算机能够处理海量数据，这些数据代表着世界的诸多方面。从这些大数据集中，我们可以以前所未有的方式洞察人类行为：语言如何被使用、照片如何被拍摄、哪些话题被讨论，以及人们如何与其周围环境互动。为了高效处理大规模数据集，程序被组织成针对顺序数据流进行操作的流水线。本章我们将探讨一套用于高效处理和操作顺序数据流的技术。
在第2章中，我们介绍了序列接口，它在Python中由list和range等内置数据类型实现。本章我们将顺序数据的概念扩展至包含具有无界甚至无限大小的集合。
### 4.2 Implicit Sequences
序列可以无需在计算机内存中显式存储每个元素来表示。也就是说，我们可以创建一种对象，它能够提供对某些顺序数据集中所有元素的访问，而无需预先计算每个元素的值。相反，我们只在需要时才按需计算元素。
这种思想的一个实例体现在第二章介绍的 range 容器类型中。一个 range 表示一段连续、有界的整数序列。然而，该序列中的每个元素并非都以显式形式存储在内存中。相反，当从 range 中请求某个元素时，该元素才会被计算出来。因此，我们可以用极小的内存空间来表示非常大的整数范围——仅需将范围的起点和终点存储为 range 对象的一部分即可。
按需计算值（而非从现有表示中检索）的方式，是惰性计算的一个典型例子。在计算机科学中，惰性计算指的是任何将值的计算延迟到该值真正被需要时才执行的程序机制。
#### 1. 迭代器
Python及许多其他编程语言提供了一种统一处理容器值元素的机制，称为迭代器。迭代器是一种能够逐个提供顺序访问值的对象。
迭代器抽象包含两个核心机制：一是获取序列中下一个元素的方法，二是标记序列已结束、无更多元素可获取的信号机制。对于列表（list）或范围（range）等任何容器，可以通过调用内置的 iter 函数获取其迭代器。通过调用内置的 next 函数即可访问迭代器中的内容。
Python 通过抛出 StopIteration 异常来标记序列中已无更多值可供获取。该异常可通过 try 语句进行处理。
迭代器通过维护局部状态来记录其在序列中的位置。每次调用 next 时，该位置会向前推进。两个独立的迭代器可以追踪同一序列中的不同位置。但指向同一迭代器的不同变量名会共享位置状态，因为它们引用的是同一个值。
推进第二个迭代器不会影响第一个迭代器。
对迭代器调用 iter 将返回该迭代器本身（而非副本）。Python 设计此行为是为了让程序员可以对任意值调用 iter 来获取迭代器，而无需担心该值本身是迭代器还是容器。
迭代器的实用性源于其底层数据序列不一定需要显式存储在内存中。迭代器提供了逐一遍历序列值的机制，而这些元素并不需要同时存储。当向迭代器请求下一个元素时，该元素可以按需计算，而无需从现有内存源中检索。
范围（range）能够惰性计算序列元素，是因为其表示的序列具有均匀性，且任一元素都易于通过范围的起止边界计算得出。迭代器则允许以惰性方式生成更广泛的底层顺序数据集，因为它们无需提供对底层序列任意元素的访问能力。迭代器仅需按顺序在每次请求时计算序列的下一个元素。虽然这种按序访问的方式不如直接访问序列任意元素（称为随机访问）灵活，但在数据处理应用中，对顺序数据的顺序访问通常已足够满足需求。
#### 2. 可迭代对象
能够生成迭代器的值称为可迭代对象。在 Python 中，可迭代对象指任何可以传递给内置函数 iter 的值。可迭代对象包括序列值（如字符串、元组）以及其他容器（如集合、字典）。迭代器本身也是可迭代的，因为它们同样可以传递给 iter 函数。
即使是字典这类无序容器，在生成迭代器时也必须为其内容定义一种顺序。字典和集合被视为“无序”，是因为程序员无法控制其迭代顺序，但 Python 在规范中明确保证其迭代顺序具有某些特定性质。
如果字典的结构因增加或删除键而发生改变，那么所有已存在的迭代器会立即失效，后续生成的迭代器也可能出现无法预料的顺序变化。不过，仅修改已存在键对应的值不会改变内容顺序，也不会导致迭代器失效。
#### 3. 内置迭代器
多个内置函数以可迭代对象作为参数并返回迭代器。这些函数被广泛应用于惰性序列处理。
map 函数具有惰性特性：调用它时并不会立即执行计算结果所需的计算操作。实际上，它会创建一个迭代器对象，只有在通过 next 查询时才会返回计算结果。
filter、zip 和 reversed 函数同样返回迭代器。
#### 4. for循环中的迭代器
Python 中的 for 语句基于迭代器运作。如果一个对象拥有返回迭代器的`__iter__`方法，那么它就是可迭代的（这是一种接口）。可迭代对象可以作为 for 语句头部的`<expression>`的值：
```python
for <name> in <expression>:
    <suite>
```
要执行 for 语句，Python 首先计算头部`<expression>`，该表达式必须得到一个可迭代值。然后对该值调用`__iter__`方法获取迭代器。接着，Python 会反复调用该迭代器的`__next__`方法，直到其引发`StopIteration`异常为止。每次调用后，Python 将返回的结果绑定到 for 语句中的`<name>`，然后执行`<suite>`。
要在 for 循环中使用迭代器，迭代器本身也必须具有`__iter__`方法。
#### 5. 生成器
生成器是一种由特殊类别的函数（称为生成器函数）返回的迭代器。生成器函数与普通函数的区别在于：其函数体不使用`return`语句，而是通过`yield`语句来返回序列中的元素。
生成器不依靠对象属性来追踪序列的进度，而是控制生成器函数的执行——每次调用生成器的 `__next__`方法时，函数会一直运行直到执行下一个`yield`语句。
尽管我们没有显式定义`__iter__`或`__next__`方法，但`yield`语句表明我们正在定义一个生成器函数。当调用生成器函数时，它不会返回某个具体的`yield`值，而是返回一个生成器（一种迭代器），该生成器能够自行返回`yield`的值。生成器对象拥有`__iter__`和`__next__`方法，每次调用`__next__`都会从上次暂停的位置继续执行生成器函数，直到遇到下一个`yield`语句。
生成器在首次调用`__next__`之前不会开始执行其生成器函数体中的任何语句。当生成器函数执行完毕（即函数返回）时，生成器会抛出`StopIteration`异常。
#### 6. 可迭代对象与迭代器
当一个对象在调用其`__iter__`方法时能返回一个迭代器，那么该对象就是可迭代的。可迭代值代表数据集合，它们提供了一种固定的数据表示方式，并且可以生成多个独立的迭代器。
内置函数 iter 会调用其参数的`__iter__`方法。在下面的表达式序列中，从同一个可迭代序列派生出的两个迭代器能够独立地依次生成字母。
迭代器负责追踪顺序数据的访问进度，而可迭代对象代表的是数据本身。
Python 中有许多内置函数接受可迭代参数并返回迭代器。
可迭代的对象实例与迭代器实例之间的关键区别在于：对象实例本身不会发生变化，而迭代器实例会随着每次调用 next（或等价的`__next__`方法）而改变状态。迭代器负责追踪顺序数据的访问进度，而可迭代对象代表的是数据本身。
Python 中有许多内置函数接受可迭代参数并返回迭代器。
#### 7. 可迭代接口
在 Python 中，迭代器对底层序列的元素只进行单次遍历。遍历结束后，再调用`__next__`将会持续引发`StopIteration`异常。许多应用需要多次遍历元素。
序列本身不是迭代器，而是可迭代对象。Python 中的可迭代接口仅包含一个消息`__iter__`，它返回一个迭代器。Python 内置的序列类型在调用其`__iter__`方法时会返回迭代器的新实例。如果一个可迭代对象每次调用`__iter__`时都返回一个全新的迭代器实例，那么它就可以被多次遍历。
可以通过实现可迭代接口来定义新的可迭代类。
1. 生成器函数定义新的可迭代类
`__iter__`方法是一个生成器函数；它返回一个生成器对象，每次调用此方法时，新的生成器都会开始一次全新的遍历。
2. `__next__`函数定义新的可迭代类
Python 迭代器接口通过一个名为`__next__`的方法定义，该方法返回它所代表的某个底层序列中的下一个元素。响应`__next__`调用时，迭代器可以执行任意计算来检索或计算下一个元素。调用`__next__`会改变迭代器的状态：它推进迭代器的位置。因此，多次调用`__next__`将返回底层序列的连续元素。Python 通过在调用`__next__`期间引发`StopIteration`异常来标记底层序列的结束。

迭代器还允许我们通过实现一个永不引发 StopIteration 异常的`__next__`方法来表示无限序列。例如，下面的 Positives 类遍历正整数的无限序列。Python 内置的 next 函数会在其参数上调用`__next__`方法。
#### 8. 流
流提供了另一种隐式表示顺序数据的方式。流是一种惰性计算的链表。与第 2 章的 Link 类类似，Stream实例响应对其第一个元素和流的剩余部分的请求。与 Link 一样，流的剩余部分本身也是一个 Stream。但与 Link 不同的是，流的剩余部分只有在被查找时才会计算，而不是预先存储。也就是说，流的剩余部分是惰性计算的。
为了实现这种惰性求值，流存储了一个用于计算剩余部分的函数。每当调用该函数时，其返回值会被缓存在流的 _rest 属性中（以下划线命名表示不应直接访问）。
可访问的属性 rest 是一个属性方法，它返回流的剩余部分，并在必要时进行计算。通过这种设计，流存储的是如何计算剩余部分，而不是始终显式存储剩余部分。
```python
>>> class Stream:
        """一个惰性计算的链表。"""
        class empty:
            def __repr__(self):
                return 'Stream.empty'
        empty = empty()

        def __init__(self, first, compute_rest=lambda: empty):
            assert callable(compute_rest), 'compute_rest must be callable.'
            self.first = first
            self._compute_rest = compute_rest

        @property
        def rest(self):
            """返回流的剩余部分，必要时计算它。"""
            if self._compute_rest is not None:
                self._rest = self._compute_rest()
                self._compute_rest = None
            return self._rest

        def __repr__(self):
            return 'Stream({0}, <...>)'.format(repr(self.first))
```
构造 Stream 实例时，字段 self._rest 为 None，表示 Stream 的剩余部分尚未计算。当通过点表达式请求 rest 属性时，会调用 rest 属性方法，从而触发计算：self._rest = self._compute_rest()。由于流内部的缓存机制，compute_rest 函数只被调用一次，之后便被丢弃。
compute_rest 函数的基本属性是：它不接受任何参数，并返回一个 Stream 或 Stream.empty。
惰性求值使我们能够使用流来表示无限的顺序数据集。
操作序列的高阶函数——map 和 filter——也适用于流，尽管它们的实现必须改为惰性地应用参数函数。函数 map_stream 将一个函数映射到流上，产生一个新的流。局部定义的 compute_rest 函数确保每当计算剩余部分时，该函数会被映射到流的剩余部分上。
```python
>>> def map_stream(fn, s):
        if s is Stream.empty:
            return s
        def compute_rest():
            return map_stream(fn, s.rest)
        return Stream(fn(s.first), compute_rest)
```
可以通过定义一个 compute_rest 函数来过滤流，该函数将过滤函数应用到流的剩余部分。如果过滤函数拒绝了流的第一个元素，则立即计算剩余部分。由于 filter_stream 是递归的，剩余部分可能会被计算多次，直到找到有效的第一个元素。
```python
>>> def filter_stream(fn, s):
        if s is Stream.empty:
            return s
        def compute_rest():
            return filter_stream(fn, s.rest)
        if fn(s.first):
            return Stream(s.first, compute_rest)
        else:
            return compute_rest()
```
map_stream 和 filter_stream 函数展示了流处理中的一个常见模式：局部定义的 compute_rest 函数在计算剩余部分时，递归地将处理函数应用到流的剩余部分。
流与迭代器的不同之处在于，它们可以被传递给纯函数多次，并且每次都会产生相同的结果。
正如链表提供了序列抽象的一个简单实现，流提供了一个简单的、函数式的递归数据结构，通过使用高阶函数来实现惰性求值。
### 4.3 Declarative Programming
除了流之外，数据值还常被存储在称为数据库的大型存储库中。数据库由存储数据值的数据仓库以及用于检索和转换这些值的接口组成。数据库中存储的每个值称为一条记录，具有类似结构的记录被分组到表中。记录通过查询来检索和转换，查询即用查询语言编写的语句。目前使用最广泛的查询语言是结构化查询语言，简称SQL（发音为"sequel"）。
SQL是声明式编程语言的一个范例。其语句并不直接描述计算过程，而是描述某些计算的预期结果。数据库系统的查询解释器负责设计和执行计算流程以生成这样的结果。
这种交互模式与Python或Scheme等过程式编程范式存在本质区别。在Python中，计算过程由程序员直接描述；而声明式语言则抽象了过程细节，专注于结果的呈现形式。
SQL语言虽然是标准化的，但大多数数据库系统都会实现某种带有专有特性的自定义变体。在本文中，我们将以Sqlite数据库实现的SQL为例，介绍其一个小子集。您可以下载Sqlite或使用在线SQL解释器来跟随学习。
#### 1. 表
表（也称为关系）由固定数量的具名列组成，每列都有指定的类型。表中的每一行代表一条数据记录，每列对应一个值。
在SQL语言中，可以通过select语句创建单行表：行值用逗号分隔，列名跟在"as"关键字后面。所有SQL语句都以分号结尾
```sql
sqlite> select 38 as latitude, 122 as longitude, "Berkeley" as name;
38|122|Berkeley
```
第二行是输出结果，每行显示为一列，列之间用竖线分隔。
多行表可以通过union操作构建，它会合并两个表的行。新表采用左表的列名。行内的空格不影响结果。
```sql
sqlite> select 38 as latitude, 122 as longitude, "Berkeley" as name union
   ...> select 42,             71,               "Cambridge"        union
   ...> select 45,             93,               "Minneapolis";
38|122|Berkeley
42|71|Cambridge
45|93|Minneapolis
```
表命名后，其名称可在select语句的from子句中使用。通过特殊的select *形式可以显示表的所有列。
```sql
sqlite> select * from cities;
38|122|Berkeley
42|71|Cambridge
45|93|Minneapolis
```
#### 2. select语句
SELECT语句通过列出单行值来定义新表，但更常见的方式是使用FROM子句对现有表进行投影操作：
```sql
select [column description] from [existing table name]
```
结果表的列由逗号分隔的表达式列表描述，每个表达式都会针对现有输入表的每一行进行计算。
列描述表达式采用与Python高度相似的语言：支持中缀运算符（如+和%）、内置函数（如abs和round）以及描述计算顺序的括号。
每个表达式可选择性地后接AS关键字和列名。当为整个表命名时，为每列赋予名称通常很有帮助，便于在后续SELECT语句中引用。通过简单名称描述的列会自动获得命名。
WHERE子句：SELECT语句还可以包含带有过滤表达式的WHERE子句。该表达式用于筛选投影行，只有过滤表达式计算结果为真的行才会出现在结果表中
ORDER子句：SELECT语句还能对结果表进行排序。ORDER子句包含一个排序表达式，该表达式会针对每个未过滤行进行计算，其结果值将作为结果表的排序依据。
这些功能的组合使得SELECT语句能够将输入表以多种形式投影到相关的输出表中。
#### 3. 连接
数据库通常包含多张表，查询时可能需要整合不同表中的信息才能计算出预期结果。
数据通过连接（join）操作进行整合——这是数据库系统的核心操作之一。虽然存在多种密切相关的连接方法，本文重点介绍其中一种。当多张表连接时，结果表将包含输入表行之间的所有组合。若左表有𝑚行、右表有𝑛行，连接后的表将包含𝑚×𝑛行。在SQL中，通过在SELECT语句的FROM子句中用逗号分隔表名来实现连接：
连接操作通常配合WHERE子句使用，以表达表间的关联关系。
当表之间存在重复列名时，需要通过表名来消除歧义；当表与自身连接时，则需要区分不同表实例。为此，SQL允许在FROM子句中使用AS关键字为表设置别名，并通过点表达式指定特定表中的列。
#### 4. 解释SQL
为了给目前介绍的SQL子集创建解释器，我们需要构建表的表示结构、文本语句的解析器，以及已解析语句的求值器。SQL解释器示例包含了所有这些组件，为声明式语言解释器提供了一个简单但功能完整的演示。
在这个实现中，每个表都有对应的类，表中的每一行由该表类的实例表示。每行对象拥有对应表列的属性，而表则是行的序列。
表的类通过Python标准库collections包中的namedtuple函数创建，该函数返回tuple的子类，并为元组的每个元素赋予名称。
以前文中的cities表为例（重复如下）：
```sql
sqlite> create table cities as
   ...>    select 38 as latitude, 122 as longitude, "Berkeley" as name union
   ...>    select 42,             71,               "Cambridge"        union
   ...>    select 45,             93,               "Minneapolis";
```
```py
>>> from collections import namedtuple
>>> CitiesRow = namedtuple("Row", ["latitude", "longitude", "name"])
>>> cities = [CitiesRow(38, 122, "Berkeley"),
              CitiesRow(42,  71, "Cambridge"),
              CitiesRow(43,  93, "Minneapolis")]
```
SELECT语句的结果可以通过序列操作来解释。以前文中的distances表为例：
```sql
sqlite> create table distances as
   ...>   select name, 60*abs(latitude-38) as distance from cities;
sqlite> select distance/5, name from distances;
0|Berkeley
48|Cambridge
84|Minneapolis
```
该表是从cities表的name和latitude列生成的。通过对输入表的行映射函数可以生成结果表，该函数为每个CitiesRow返回一个DistancesRow：
```py
>>> DistancesRow = namedtuple("Row", ["name", "distance"])
>>> def select(cities_row):
        latitude, longitude, name = cities_row
        return DistancesRow(name, 60*abs(latitude-38))
>>> distances = list(map(select, cities))
>>> for row in distances:
        print(row)
Row(name='Berkeley', distance=0)
Row(name='Cambridge', distance=240)
Row(name='Minneapolis', distance=300)
```
我们的SQL解释器设计推广了这种方法。SELECT语句表示为Select类的实例，该实例根据SELECT语句的子句构造：
```py
>>> class Select:
        """select [columns] from [tables] where [condition] order by [order]."""
        def __init__(self, columns, tables, condition, order):
            self.columns = columns
            self.tables = tables
            self.condition = condition
            self.order = order
            self.make_row = create_make_row(self.columns)
        def execute(self, env):
            """连接、过滤、排序输入表的行，并映射到输出列"""
            from_rows = join(self.tables, env)
            filtered_rows = filter(self.filter, from_rows)
            ordered_rows = self.sort(filtered_rows)
            return map(self.make_row, ordered_rows)
        def filter(self, row):
            if self.condition:
                return eval(self.condition, row)
            else:
                return True
        def sort(self, rows):
            if self.order:
                return sorted(rows, key=lambda r: eval(self.order, r))
            else:
                return rows
```
execute方法连接输入表，过滤并排序结果行，然后通过make_row函数映射这些结果行。make_row函数在Select构造函数中通过调用高阶函数create_make_row创建，该函数为结果表生成新类，并定义如何将输入行投影到输出行。（sql模块中包含了具有更多错误处理和特殊情况的版本。
```py
>>> def create_make_row(description):
        """返回从输入环境（字典）到输出行的函数。
        description -- 逗号分隔的[表达式] as [列名]列表
        """
        columns = description.split(", ")
        expressions, names = [], []
        for column in columns:
            if " as " in column:
                expression, name = column.split(" as ")
            else:
                expression, name = column, column
            expressions.append(expression)
            names.append(name)
        row = namedtuple("Row", names)
        return lambda env: row(*[eval(e, env) for e in expressions])
```
最后，我们需要定义创建输入行的join函数。给定包含现有表（行列表）的env字典（以表名为键），join函数使用itertools包中的product函数将输入表中所有行组合分组。它通过make_env函数映射连接后的行，该函数将每行组合转换为字典以便用于表达式求值。（sql模块中包含了具有更多错误处理和特殊情况的版本。
```py
>>> from itertools import product
>>> def join(tables, env):
        """返回从名称到行值的字典迭代器。
        tables -- 逗号分隔的表名序列
        env    -- 从全局名称到表的字典
        """
        names = tables.split(", ")
        joined_rows = product(*[env[name] for name in names])
        return map(lambda rows: make_env(rows, names), joined_rows)
>>> def make_env(rows, names):
        """创建绑定值到名称的环境"""
        env = dict(zip(names, rows))
        for row in rows:
            for name in row._fields:
                env[name] = getattr(row, name)
        return env
```
其中row._fields求值为该行所属表的列名。存在_fields属性是因为row的类型是namedtuple类。
我们的解释器已足够完整，可以执行SELECT语句。例如，我们可以计算所有其他城市与伯克利的纬度距离，并按经度排序：
```py
>>> env = {"cities": cities}
>>> select = Select("name, 60*abs(latitude-38) as distance",
                    "cities", "name != 'Berkeley'", "-longitude")
>>> for row in select.execute(env):
        print(row)
Row(name='Minneapolis', distance=300)
Row(name='Cambridge', distance=240)
```
以上示例等价于以下SQL语句：
```sql
sqlite> select name, 60*abs(latitude-38) as distance
   ...>        from cities where name != "Berkeley" order by -longitude;
Minneapolis|420
Cambridge|240
```
我们还可以将结果表存储在环境中，并将其与cities表连接，获取每个城市的经度：
```py
>>> env["distances"] = list(select.execute(env))
>>> joined = Select("cities.name as name, distance, longitude", "cities, distances",
                    "cities.name == distances.name", None)
>>> for row in joined.execute(env):
        print(row)
Row(name='Cambridge', distance=240, longitude=71)
Row(name='Minneapolis', distance=300, longitude=93)
```
以上示例等价于以下SQL语句
```sql
sqlite> select cities.name as name, distance, longitude
   ...>        from cities, distances where cities.name = distances.name;
Cambridge|240|71
Minneapolis|420|93
```
完整的sql示例程序还包含SELECT语句的简单解析器，以及CREATE TABLE和UNION的execute方法。该解释器能够正确执行到目前为止文本中包含的所有SQL语句。虽然这个简单的解释器只实现了完整结构化查询语言的一小部分，但其结构展示了序列处理操作与查询语言之间的关系。
查询计划：声明式语言描述结果的形式，但不显式描述应如何计算该结果。该解释器总是按顺序进行连接、过滤、排序，然后投影输入行以计算结果行。然而，可能存在更高效的计算方式，查询解释器可以自由选择。选择高效的计算查询结果过程是数据库系统的核心特性。
例如，考虑上述最后的SELECT语句。与其先计算cities和distances的连接再过滤结果，不如通过首先按name列对两个表排序，然后在有序表线性遍历时仅连接具有相同name的行来计算相同结果。当表数据量庞大时，查询计划选择带来的效率提升可能非常显著。
#### 5. 递归select语句
SELECT语句可选用WITH子句来生成并命名用于最终结果计算的附加表。完整的SELECT语句语法（不包括UNION）具有以下形式：
```sql
with [tables] select [columns] from [names] where [condition] order by [order]
```
我们已经演示过[columns]和[names]的允许值。[condition]和[order]是针对输入行求值的表达式。[tables]部分是以逗号分隔的表描述列表，形式为：
```sql
[table name]([column names]) as ([select statement])
```
任何SELECT语句都可用于描述[表格]中的表。
WITH子句中定义的表可以包含递归定义，通过其他输出行来定义新的输出行。
WITH子句可用逗号分隔定义多个表。
设计递归查询时，需确保每个输入行包含计算结果行所需的适当信息。
#### 6. 字符串构建
字符串构建：在SQL中可以使用||运算符连接两个字符串
此功能可用于通过连接短语构建句子。
#### 7. 聚合和分组
目前介绍的SELECT语句能够进行连接、投影和单行数据操作。此外，SELECT语句还能对多行数据执行聚合操作。聚合函数max、min、count和sum分别返回某列的最大值、最小值、行数和总和。通过对同一组行定义多列可以应用多个聚合函数。聚合时只考虑WHERE子句筛选后的列。
distinct关键字确保聚合时不包括列中的重复值。特殊的count(*)语法用于统计行数。
以上SELECT语句都生成单行表。SELECT语句的group by和having子句用于将行分组并筛选部分组。having子句或列描述中的聚合函数将独立应用于每个组，而非整个表的所有行。
group by子句可包含多列和完整表达式，系统将为每个唯一的数值组合创建分组。通常分组表达式也会出现在列描述中，以便识别每个结果行对应的分组。
having子句可包含与where子句相同的过滤条件，还能调用聚合函数。为获得最快执行速度和最清晰的语言使用，基于行内容的个体过滤条件应放在where子句，而having子句应仅用于需要聚合的条件（如指定组的最小计数）。
使用group by子句时，列描述可以包含不聚合的表达式。某些情况下，SQL解释器会选择与包含聚合的其他列对应的行值。例如，以下语句给出体重最大动物的名称：
然而，当对应聚合的行不明确时（例如使用count而非max进行聚合），所选值可能具有任意性。为获得最清晰和可预测的语言使用，包含group by子句的SELECT语句应至少包含一个聚合列，且仅当非聚合列内容可从聚合中预测时才包含它们。
### 4.4 Logic Programming
[非重点内容，详情请参照官方教材](https://www.composingprograms.com/pages/44-logic-programming.html)
### 4.5 Unification
[非重点内容，详情请参照官方教材](https://www.composingprograms.com/pages/45-unification.html)
### 4.6 Distributed Computing
[非重点内容，详情请参照官方教材](https://www.composingprograms.com/pages/46-distributed-computing.html)
### 4.7 Distributed Data Processing
[非重点内容，详情请参照官方教材](https://www.composingprograms.com/pages/47-distributed-data-processing.html)
### 4.8 Parallel Computing
[非重点内容，详情请参照官方教材](https://www.composingprograms.com/pages/48-parallel-computing.html)
___
[返回目录](#目录)
___